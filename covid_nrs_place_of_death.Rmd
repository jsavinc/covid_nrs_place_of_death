---
title: "Place of death in NRS COVID-19 deaths"
author: "Jan Savinc"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load packages

```{r, warning=FALSE, message=FALSE}
## install packages from github if not yet available!
# remotes::install_github("datasciencescotland/opendatascot", force = TRUE)
# remotes::install_github("Health-SocialCare-Scotland/phsmethods", force = TRUE)

library(tidyverse)  # for tidy workflow
library(opendatascot)  # importing data from ScotGov open data website
library(phsmethods)  # methods for working with PHS data
library(readxl)  # for reading excel files
# library(SPARQL)  # taken care of by opendatascot
library(lubridate)  # dealing with dates
library(janitor)  # for cleaning column names
library(ISOweek)  # for computing date from ISO week number + year
```


# Set up SPARQL query

Note: not needed if using `opendatascot`
To access the latest NRS data using their API, we first setup a SPARQL query.

```{r}
endpoint <- "http://statistics.gov.scot/sparql.json"
```


# Import & wrangle data

We're importing two kinds of data:

1. Weekly deaths involving COVID-19 from Scottish gov't open data service, broken down by week & place of death (home or institution)
2. Historical deaths 2015-2019, grouped by week & place of death

For both of these, we'll also look at crosstabulated figures for:

* Health board
* Local Authority
* Sex
* Age
* ~~Ethnicity~~ Note: not sure this is available

There are two ways of obtaining the data:

1. Using their SPARQL-based API ("data cube"), which can be accessed using the `opendatascot` package in R; the data can be seen on [the Scottish Gov't open data website](https://statistics.gov.scot/data/deaths-involving-coronavirus-covid-19)
2. There are a number of dataset, including the demographic/geographic crosstabulations available on the "Related Statistics" section of the [deaths involving COVID-19 website]( https://www.nrscotland.gov.uk/statistics-and-data/statistics/statistics-by-theme/vital-events/general-publications/weekly-and-monthly-data-on-births-and-deaths/deaths-involving-coronavirus-covid-19-in-scotland)

Note that the [*About* tab of the "data cube" interface](https://statistics.gov.scot/resource?uri=http%3A%2F%2Fstatistics.gov.scot%2Fdata%2Fdeaths-involving-coronavirus-covid-19) says the following about Health Board & Local Authority figures:

>Health Board and Local Authority figures include non-residents. Deaths are allocated to areas based on the usual residence of the deceased. If the deceased was not a Scottish resident, the death is allocated to the area where the death occurred.

This means we'll need to download those figures from the website rather than using the API

Note that the weekly deaths due to COVID-19 in 2020 & 2021 also include a weekly average 2015-2019, but for the purposes of showing the range of deaths (weekly minima & maxima), we need the weekly figures for individual years & the appropriate cross-tabulations.

## Parsing week numbers

In the `opendatascot`-imported data, `refPeriod` refers to the week number (called `week of occurrence` in the `.xlsx`/`.csv`-imported data has), as defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date), and can be computed from a date with `lubridate::isoweek()`; the first week of 2020 is the week starting with Monday 2019-12-30, ~~and the corresponding start dates for each week can be computed by adding weeks using `lubridate::dweeks()` to that date.~~ This is non-trivial, because the number of iso weeks in a year isn't constant. The `ISOweek::ISOweek2date()` function deals with this issue in a crude manner, and allows us to compute the date (w/c on date) from the year & week number. It relies on being provided a valid week number (some years have 52 and some have 53), but it's probably safe to assume that the NRS data has valid dates.

Invalid week numbers will produce a date in the next year: e.g. week 53 in 2021 would actually start in 2022, which makes it invalid. We can test for that by checking that the year provided is the same year in the date produced.

We'll also compute a 'run-over' week number of 2021 in case we plot both years on a contibuous X-axis - in this case, week 1 of 2021 follows week 53 of 2020, so we start counting from 54 in 2021.

```{r}
date_first_week_2020 <- ymd("2019-12-30")
ISOweek::ISOweek2date(weekdate = "2019-W53-1")
ISOweek::ISOweek2date(weekdate = "2020-W01-1")
ISOweek::ISOweek2date(weekdate = "2020-W52-1")
ISOweek::ISOweek2date(weekdate = "2020-W53-1")
ISOweek::ISOweek2date(weekdate = "2021-W01-1")
ISOweek::ISOweek2date(weekdate = "2021-W53-1")

compute_start_date_from_week_number <- function(week_number, year_number) {
  ## this assumes a valid week number! There are 52 or 53 weeks in a year
  isoweek_string <- glue::glue("{year_number}-W{str_pad(week_number, width=2, pad='0')}-1")
  computed_dates <- ISOweek::ISOweek2date(isoweek_string)
  ## invalid weeks will result in a computed date in a year after the requested year...
  ## a valid week can result in a date that starts in the year before!
  if (any(year_number<year(ymd(computed_dates)))) stop("invalid week number provided!")
  return(computed_dates)
}

tibble(
    week_number = c(1,2,3,52,53)
  ) %>%
  mutate(
    date = compute_start_date_from_week_number(week_number = week_number, year_number = 2020),
    iso_week_from_date = isoweek(date)
  ) %>% knitr::kable(caption = "Examples of computing start date for each week, and computing isoweek from the dates!")
```

## Load weekly COVID-19 related deaths

~~Using `opendatascot` to load weekly deaths the level of geography can be specified, so we can have more or less granular data~~ Choosing a more granular level than Scotland-wide data means place of death is collapsed to the 'all' category only, see note above!

```{r}
# checking out structure

# ods_all_datasets() %>% View()
# ods_structure("deaths")  # can we import all deaths-related data this way?
# ods_print_query("deaths")

# ods_structure("deaths-involving-coronavirus-covid-19")
# ods_schemes("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19", geography = "la")
# ods_find_lower_geographies("S92000003")  # Scotland's refArea = S92000003
# phsmethods::match_area("S92000003")  # "Scotland"

make_human_readable_ref_area <- function(data_tbl, ref_area = refArea) {
  enquoted_ref_area <- enquo(ref_area)
  data_tbl %>%
    mutate(
      !!enquoted_ref_area := phsmethods::match_area(!!enquoted_ref_area)
    )
}
# raw_covid_deaths <- list(
#   scotland = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc"),
#   health_board = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "hb"),
#   local_authority = ods_dataset("deaths-involving-coronavirus-covid-19",geography = "la")
# ) %>%
#   map(.x = ., .f = ~make_human_readable_ref_area(data_tbl = .x))

weekly_deaths_by_age_sex <-
  ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc") %>%
  make_human_readable_ref_area %>%
  clean_names() %>%
  rename(
    number_of_deaths = value,
    place_of_death = location_of_death  # so it's the same as everywhere else!
  ) %>%
  filter(!ref_period %in% as.character(2020:2021)) %>% # remove totals for 2020 & 2021
  mutate(
    year = parse_integer(str_extract(ref_period, pattern="^(2020|2021)")),
    week_number = parse_integer(str_remove(ref_period, pattern = "^(2020|2021)\\-")),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    number_of_deaths = as.numeric(number_of_deaths),  # convert to numeric!
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  select(-c(measure_type))  #  measure_type is count for all data
  

weekly_deaths_by_la_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-council-area-location.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

weekly_deaths_by_la <- 
  read_excel(weekly_deaths_by_la_file, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = council, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year)
  )

weekly_deaths_by_hb_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

weekly_deaths_by_hb <- 
  read_excel(weekly_deaths_by_hb_file, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = health_board, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year)
  )


# TODO: split this into a scotland-wide dataset, and grouped by health board & council area
covid_deaths_raw <- bind_rows(
  ods_dataset("deaths-involving-coronavirus-covid-19",geography = "sc")#,
  # ods_dataset("deaths-involving-coronavirus-covid-19",geography = "la"),
  # ods_dataset("deaths-involving-coronavirus-covid-19",geography = "hb")
)

ods_dataset("deaths-involving-coronavirus-covid-19")

```


## Download historical deaths data

These are all downloaded from the NRS website to a temporary file created by the `tempfile()` function.

```{r}
## overall file - where did I get the link from? it's not obviously available from the website...
past_deaths_overall_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files/statistics/covid19/weekly-deaths-by-location-2015-2019.csv",
                destfile = tempfile(),
                quiet = FALSE)

past_deaths_health_board_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location-15-19.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

past_deaths_council_area_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-council-areas.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

past_deaths_age_sex_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-age-group-sex-15-19.xlsx",
                destfile = tempfile(),
                quiet = FALSE)
```


### Overall data

```{r}
past_deaths_overall <- 
  read_csv(past_deaths_overall_file, skip = 2) %>%
  rename(year = 1) %>%  # rename first column
  mutate(
    place_of_death = if_else(is.na(`1`), true = year, NA_character_)
  ) %>%
  fill(place_of_death, .direction="down") %>%  # LOCF on place_of_death
  drop_na(`1`) %>%
  pivot_longer(cols = all_of(as.character(1:53)), values_to = "number_of_deaths", names_to = "week_number") %>%
  mutate(week_number=as.integer(week_number))

# past_deaths_overall %>% filter(week_number %in% 52:53) %>% count(year, week_number)
```


### Grouped by health board, council area, and age & sex

The format of the .xlsx files is that sheet 1 is a table of contents, sheet 2 contains the data, and sheet 3 is a pivot table for subsetting data.

The total deaths by place of death don't add up between the overall deaths & health board. This may be due to small numbers being redacted?

```{r, warning=FALSE}
past_deaths_health_board <- 
  readxl::read_excel(past_deaths_health_board_file, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  rename(
    week_number = week_of_occurrence,
    place_of_death = location
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  drop_na(week_number)  # remove empty rows & one row where it's just the copyright notice

past_deaths_council_area <-
  readxl::read_excel(past_deaths_council_area_file, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  rename(
    week_number = week,
    place_of_death = location_of_death
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  drop_na(week_number)  # remove empty rows & one row where it's just the copyright notice

past_deaths_age_sex <-  # structure here is a bit more complicated - headers in row 3, but sex & age headers in row 4
  readxl::read_excel(past_deaths_age_sex_file, sheet = 2, skip = 4, col_names = c("year","week_number","place_of_death","sex","age","number_of_deaths"), guess_max = 1e5) %>%
  mutate(
    year = 2000L + as.integer(year),
    week_number = as.integer(week_number)
  ) %>%
  drop_na(year)  # remove empty rows & one row where it's just the copyright notice

## check that the results are the same as overall deaths
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_health_board, past_deaths_council_area, past_deaths_age_sex),
  .y = c("overall","health_board","council_area","age_sex"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(!is.na(year) & place_of_death!="All locations") %>%
      group_by(dataset,year) %>%
        summarise(total = sum(number_of_deaths))
  }
) %>% 
  pivot_wider(names_from=year,values_from=total) %>%
  knitr::kable(caption = "Number of deaths by year as calculated from different datasets. All datasets apart from the split by health board agree. The differences in the health board dataset likely reflect missing values and/or small numbers redacted from the dataset, which may have to do with the grouping of state hospital/non-NHS institutions.")
```


# Wrangling the data

```{r}
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_health_board, past_deaths_council_area, past_deaths_age_sex),
  .y = c("overall","health_board","council_area","age_sex"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(year %in% 2016:2019 & week_number==53) %>%
      count(dataset,year)
  }
) %>% 
  pivot_wider(names_from=year,values_from=n) %>%
  knitr::kable(caption = "Number of entries by dataset for week number 53 in years 2016-2019 (which only had 52 weeks). Only the 'overall' historical deaths dataset has week 53 entries for years with 52 weeks, and all the entries are for 0 deaths.")

## helper function that creates week 53 data by taking week 52 in years with no year 53 and relabels it as 53
## CAUTION: only use this for computing averages! otherwise it's making up data that wasnae there
create_week_53_data_for_years_with_52_weeks <- function(data_tbl) {
  real_data <-
    data_tbl %>%
    filter(!(year %in% 2016:2019 & week_number==53))  # remove any entries for week 53 in years with 52 weeks - in some datasets they existed but had 0 listed
  fake_data <-
    data_tbl %>%
    filter(year %in% 2016:2019 & week_number==52) %>%
    mutate(week_number=53)
  return(
    bind_rows(
      real_data,
      fake_data
    )
  )
}

past_deaths_overall_summarised <-
  past_deaths_overall %>%
  filter(year!="average") %>%  # remove averages
  group_by(year, week_number) %>%  # remove week 53 if it was 0 for all places  - this means there was no week 53!
  filter(!all(number_of_deaths==0 & week_number==53)) %>%
  ungroup %>%
  create_week_53_data_for_years_with_52_weeks %>%
  ungroup %>%
  group_by(week_number,place_of_death) %>% 
  summarise(across(number_of_deaths, .fns = list(mean=mean,min=min,max=max)),  # having removed 0s for week 53 where it didn't exist, we average over years for week 53 that had that week only
    .groups = "drop"
  ) %>% rename_all(~str_replace_all(.x, pattern = "number_of_deaths", replacement = "deaths"))


week_53_text <- "Due to the way ISO 8601 counts weeks, only 2015 in the 2015-2019 period had 53 weeks; averages for week 53 were computed from figures for week 53 in 2015 and week 52 for 2016-2019."

# TODO: weekly averages may be too detailed for this level od subcategorising!

historical_range_by_health_board <-
  past_deaths_health_board %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, health_board
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_range_by_council_area <-
  past_deaths_council_area %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, council_area
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_range_by_age_sex <-
  past_deaths_age_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_range_by_age <-
  past_deaths_age_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_range_by_sex <-
  past_deaths_age_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )
```


## Understanding how dates are coded

`refPeriod` refers to the week number, as defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date), and can be computed from a date with `lubridate::isoweek()`; the first week of 2020 is the week starting with Monday 2019-12-30, ~~and the corresponding start dates for each week can be computed by adding weeks using `lubridate::dweeks()` to that date.~~ This is non-trivial, because the number of iso weeks in a year isn't constant. The `ISOweek::ISOweek2date()` function deals with this issue in a crude manner, and allows us to compute the date (w/c on date) from the year & week number. It relies on being provided a valid week number (some years have 52 and some have 53), but it's probably safe to assume that the NRS data has valid dates.

Invalid week numbers will produce a date in the next year: e.g. week 53 in 2021 would actually start in 2022, which makes it invalid. We can test for that by checking that the year provided is the same year in the date produced.

```{r}
date_first_week_2020 <- ymd("2019-12-30")
ISOweek::ISOweek2date(weekdate = "2019-W53-1")
ISOweek::ISOweek2date(weekdate = "2020-W01-1")
ISOweek::ISOweek2date(weekdate = "2020-W52-1")
ISOweek::ISOweek2date(weekdate = "2020-W53-1")
ISOweek::ISOweek2date(weekdate = "2021-W01-1")
ISOweek::ISOweek2date(weekdate = "2021-W53-1")

compute_start_date_from_week_number <- function(week_number, year_number) {
  ## this assumes a valid week number! There are 52 or 53 weeks in a year
  isoweek_string <- glue::glue("{year_number}-W{str_pad(week_number, width=2, pad='0')}-1")
  computed_dates <- ISOweek::ISOweek2date(isoweek_string)
  ## invalid weeks will result in a computed date in a year after the requested year...
  ## a valid week can result in a date that starts in the year before!
  if (any(year_number<year(ymd(computed_dates)))) stop("invalid week number provided!")
  return(computed_dates)
}

tibble(
    week_number = c(1,2,3,52,53)
  ) %>%
  mutate(
    date = compute_start_date_from_week_number(week_number = week_number, year_number = 2020),
    iso_week_from_date = isoweek(date)
  ) %>% knitr::kable(caption = "Examples of computing start date for each week, and computing isoweek from the dates!")
```


## Recoding dates

```{r}
covid_deaths <-
  raw_covid_deaths %>%
  map(
    .x = .,
    .f = function(data_tbl) {
      data_tbl %>%
      clean_names() %>%
      rename(
        number_of_deaths = value,
        place_of_death = location_of_death  # so it's the same as everywhere else!
      ) %>%
      filter(!ref_period %in% as.character(2020:2021))  %>% # remove totals for 2020 & 2021
      mutate(
        year = parse_integer(str_extract(ref_period, pattern="^(2020|2021)")),
        week_number = parse_integer(str_remove(ref_period, pattern = "^(2020|2021)\\-")),
        date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
        number_of_deaths = as.numeric(number_of_deaths)  # convert to numeric!
      ) %>%
      select(-c(measure_type))  #  measure_type is count for all data
    }
  )

# TODO: remove this
deaths_by_cause <- 
  covid_deaths_raw %>%
  clean_names() %>%
  rename(
    number_of_deaths = value,
    place_of_death = location_of_death  # so it's the same as everywhere else!
  ) %>%
  filter(!ref_period %in% as.character(2020:2021))  %>% # remove totals for 2020 & 2021
  mutate(
    year = parse_integer(str_extract(ref_period, pattern="^(2020|2021)")),
    week_number = parse_integer(str_remove(ref_period, pattern = "^(2020|2021)\\-")),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    number_of_deaths = as.numeric(number_of_deaths)  # convert to numeric!
  ) %>%
  select(-c(ref_area, measure_type))  # ref_area is Scotland for all records; measure_type is count

## check date conversion
covid_deaths$scotland %>% count(ref_period, date_w_c) %>% slice(1:3, (nrow(.) - 3):nrow(.)) %>% knitr::kable(caption = "Checking the computation of 'date w/c' from year & week number - note how the 1st week of 2020 started in 2019.")
```


## Recoding place of death

Place of death was named differently between datasets (location/place) and the different places were also named slightly differently, so we find all of them and recode them to the same:

```{r}
unique_places_of_death_from_data <- map(
  .x = c(covid_deaths,list(past_deaths_overall, past_deaths_health_board, past_deaths_council_area, past_deaths_age_sex)),
  .f = function(x) {x$place_of_death}
  ) %>% unlist %>% unique %>% sort


# datapasta::tribble_paste(input_table = tibble(place_of_death = unique_places_of_death_from_data))
tbl_recoded_place_of_death <- 
  tibble::tribble(
                   ~place_of_death, ~place_of_death_recoded,
                             "all", "All",
                       "care-home", "Care home",
                "-non-institution", "Home & other non-institution",
               "other-institution", "Other",
                        "hospital", "Hospital",
                       "Care Home", "Care home",
  "Home and other non-institution", "Home & other non-institution",
                        "Hospital", "Hospital",
              "Other institution3", "Other",
                   "All locations", "All",
          "Home / Non-institution", "Home & other non-institution",
               "Other institution", "Other"
  ) %>%
  mutate(place_of_death_recoded = factor(place_of_death_recoded, levels = c("Hospital", "Care home", "Home & other non-institution", "Other", "All")))

## helper function to recode place of death
recode_place_of_death <- function(data_tbl) {
  data_tbl %>%
  left_join(x = ., y = tbl_recoded_place_of_death) %>% 
  select(-place_of_death) %>%
  distinct  # just in case?
}

## this is dumb, but it works!
covid_deaths <- map(.x = covid_deaths, .f = ~recode_place_of_death(.x))
# deaths_by_cause <- recode_place_of_death(deaths_by_cause)
past_deaths_overall <- recode_place_of_death(past_deaths_overall)
past_deaths_health_board <- recode_place_of_death(past_deaths_health_board)
past_deaths_council_area <- recode_place_of_death(past_deaths_council_area)
past_deaths_age_sex <- recode_place_of_death(past_deaths_age_sex)
past_deaths_overall_summarised <- recode_place_of_death(past_deaths_overall_summarised)

historical_range_by_age <- recode_place_of_death(historical_range_by_age)
historical_range_by_age_sex <- recode_place_of_death(historical_range_by_age_sex)
historical_range_by_sex <- recode_place_of_death(historical_range_by_sex)
historical_range_by_council_area <- recode_place_of_death(historical_range_by_council_area)
historical_range_by_health_board <- recode_place_of_death(historical_range_by_health_board)
```


## Merge weekly COVID/non-COVID-related deaths in 2020/2021 with historic death rates

### Check weekly historic averages against NRS computed data

```{r}
covid_deaths$scotland %>%
  filter(cause_of_death=="all-causes-average-of-corresponding-week-over-previous-5-years") %>%
  select(week_number, year = year, place_of_death_recoded, nrs_computed_mean = number_of_deaths) %>%
  left_join(past_deaths_overall_summarised) %>%
  filter(round(nrs_computed_mean) != round(deaths_mean))
  knitr::kable(caption = "Subset of weekly deaths where calculate mean deaths 2015-2019 differed between the COVID-19 related deaths file and the weekly deaths file. Week 53 was computed as the average of deaths in week 53 in 2015 and week 52 in 2016-2019. For all the other datasets the mean deaths computed agree!")
```

### Merge figures for grouping by...

```{r}
## helpewr function to pivot all deaths and non-covid deaths into separate columns
split_deaths_due_to_covid_and_not <- function(data_tbl) {
  data_tbl %>%
  filter(cause_of_death!="all-causes-average-of-corresponding-week-over-previous-5-years") %>%
  pivot_wider(names_prefix = "deaths_", names_from=cause_of_death, values_from=number_of_deaths) %>%
  clean_names() %>%
  mutate(deaths_non_covid_related = deaths_all_causes - deaths_covid_19_related)
}

## helper function to compute a "run-over" week number - weeks 54+ are in 2021
compute_run_over_week_for_2021 <- function(data_tbl) {
  data_tbl %>%
  mutate(
    week_number_run_over = if_else(year == 2021, 53 + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  )
}

merged_data_overall <-
  covid_deaths$scotland %>%
  split_deaths_due_to_covid_and_not %>%
  left_join(past_deaths_overall_summarised %>% mutate(sex = "all", age = "all"),  # only merge for aggregated data b/c that's all we have!
            by = c("place_of_death_recoded", "week_number", "sex", "age")) %>% 
  compute_run_over_week_for_2021

# TODO: get health board & council area in ODS export!
merged_deaths_by_health_board <-
  covid_deaths$health_board %>%
  split_deaths_due_to_covid_and_not %>%
  # inner_join(historical_range_by_health_board, by = c("week_number","place_of_death_recoded","ref_area"="health_board")) %>%
  inner_join(historical_range_by_health_board, by = c("week_number","ref_area"="health_board","place_of_death_recoded")) %>%
  compute_run_over_week_for_2021

merged_deaths_by_council_area <-
  deaths_by_cause %>%
  split_deaths_due_to_covid_and_not %>%
  left_join(historical_range_by_council_area) %>%
  compute_run_over_week_for_2021

merged_deaths_by_age_sex <-
  deaths_by_cause %>%
  split_deaths_due_to_covid_and_not %>%
  left_join(historical_range_by_age_sex) %>%
  compute_run_over_week_for_2021

merged_deaths_by_age <-
  deaths_by_cause %>%
  split_deaths_due_to_covid_and_not %>%
  left_join(historical_range_by_age) %>%
  compute_run_over_week_for_2021

merged_deaths_by_sex <-
  deaths_by_cause %>%
  split_deaths_due_to_covid_and_not %>%
  left_join(historical_range_by_sex) %>%
  compute_run_over_week_for_2021
```



# Visualisations

## Common elements

```{r}
date_range_text <- glue::glue("Data from w/c {format(min(deaths_by_cause$date_w_c), '%d %B %Y')} to w/c {format(max(deaths_by_cause$date_w_c), '%d %B %Y')} (inclusive).") 

source_nrs_text <- "Source: National Records of Scotland"
```



## Number of deaths by age group

```{r, fig.width=12, fig.height=9}
## graph format copied from: https://github.com/davidhen/nrs_covid_stats/
deaths_by_cause %>% 
  filter(sex == "all" & place_of_death == "all" & cause_of_death == "covid-19-related") %>% 
  filter(age != "all") %>% 
  group_by(age) %>% 
  summarise(n = sum(number_of_deaths)) %>%
  mutate(pct = round(n/sum(n), 3)) %>% 
  ggplot(aes(age, n)) +
  geom_col(fill = "#4477AA") +
  geom_text(aes(label = scales::percent(pct, accuracy = 0.1), y = n + 80)) +
  theme_minimal() +
  labs(x = "",
       y = "",
       title = "Deaths Associated with COVID-19 by Age Group",
       subtitle = date_range_text,
       caption = paste0(c(date_range_text,source_nrs_text), collapse="\n")
  )
```


## Figure 6: Recorded deaths in Scotland, by week number & location

```{r, fig.width=12, fig.height=9}
vertical_line_text <- "Vertical dotted line at week number 54 represents start of 2021."

removed_other_category_text <- glue::glue("Excluding 'Other' institutional place of death, N={merged_data_overall %>% filter(sex == 'all' & age == 'all' & place_of_death_recoded == 'Other') %>% .$deaths_all_causes %>% sum} for weeks 1-{max(merged_data_overall %>% filter(year==2020) %>% .$week_number)} in 2020 and 1-{max(merged_data_overall %>% filter(year==2021) %>% .$week_number)} in 2021.")

annotations_figure_6 <-
# datapasta::tribble_paste(tbl_recoded_place_of_death %>% select(place_of_death_recoded))
  tibble::tribble(
    ~place_of_death_recoded, ~x, ~y, ~label,
                 "Hospital", 20L, 850, "Shaded area shows range of 2015-2019 deaths; dashed line shows weekly average",
                 "Hospital", 25L, 250, "Hospital deaths dipped below historical minimum and remained low until Winter.",
                "Care home", 35L, 500, "After initial peak, deaths returned to historical range; non-Covid deaths remained low.",
                     "Home", 35L, 500, "The gap between historical high and both types of death at home was high throughout."
                  ) %>% 
  mutate(
    place_of_death_recoded = factor(place_of_death_recoded, levels = levels(tbl_recoded_place_of_death$place_of_death_recoded)),  # needs to be factor with same levels, otherwise it messes up level order when added as geom_text later!
    label = str_wrap(label, width = 40)
    )

# figure_6_location_of_death <-
  merged_data_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(!place_of_death_recoded %in% c("All","Other")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid_related), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  geom_text(data = annotations_figure_6, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~place_of_death_recoded) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

map(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_6_location_of_death",.x), plot = figure_6_location_of_death, width = 12, height = 9, dpi = 300)
)

figure_6_location_of_death
```


## Figure 7: deaths at home

```{r}
# TODO

```


## Figure 8: deaths at home, by health board

```{r}
# TODO: fix this once we have health board in weekly deaths!
merged_deaths_by_health_board %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death_recoded == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid_related), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  # geom_text(data = annotations_figure_6, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~health_board) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       # caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )
```


## Figure 10: deaths at home by sex

```{r}
merged_deaths_by_sex %>%
  filter(sex != "all" & age == "all") %>%
  filter(place_of_death_recoded == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid_related), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  # geom_text(data = annotations_figure_6, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~sex) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       # caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )
```

