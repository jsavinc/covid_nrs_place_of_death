---
title: "Place of death in NRS COVID-19 deaths"
author: "Jan Savinc"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load packages

```{r, warning=FALSE, message=FALSE}
## install packages from github if not yet available!
# remotes::install_github("datasciencescotland/opendatascot", force = TRUE)
# remotes::install_github("Health-SocialCare-Scotland/phsmethods", force = TRUE)

library(tidyverse)
library(opendatascot)
library(phsmethods)
# library(SPARQL)  # taken care of by opendatascot
library(lubridate)
library(janitor)
library(ISOweek)  # for computing date from ISO week number + year
```


# Set up SPARQL query

Note: not needed if using `opendatascot`
To access the latest NRS data using their API, we first setup a SPARQL query.

```{r}
endpoint <- "http://statistics.gov.scot/sparql.json"
```


# Import data

```{r}
# checking out structure
ods_structure("deaths-involving-coronavirus-covid-19")
ods_schemes("deaths-involving-coronavirus-covid-19")
ods_print_query("deaths-involving-coronavirus-covid-19")


data_raw <- ods_dataset("deaths-involving-coronavirus-covid-19",geography = "sc")

# TODO: remove below bit, it's for comparison with previous results!
cv_data_raw <- read_csv("https://statistics.gov.scot/downloads/cube-table?uri=http%3A%2F%2Fstatistics.gov.scot%2Fdata%2Fdeaths-involving-coronavirus-covid-19")
cv_data_main <- cv_data_raw %>% 
  clean_names() %>% 
  filter(feature_code == "S92000003") %>% 
  mutate(date_code = str_replace(date_code, "w/c ", ""),
         date_code = ymd(date_code)) %>% 
  filter(!is.na(date_code)) %>% 
  select(date_code, sex, age, cause_of_death, location_of_death, measurement, value, 
         -feature_code, -units) %>% 
  arrange(date_code, sex, age, cause_of_death, location_of_death, measurement)
```


## Understanding how dates are coded

`refPeriod` refers to the week number, as defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date), and can be computed from a date with `lubridate::isoweek()`; the first week of 2020 is the week starting with Monday 2019-12-30, ~~and the corresponding start dates for each week can be computed by adding weeks using `lubridate::dweeks()` to that date.~~ This is non-trivial, because the number of iso weeks in a year isn't constant. The `ISOweek::ISOweek2date()` function deals with this issue in a crude manner, and allows us to compute the date (w/c on date) from the year & week number. It relies on being provided a valid week number (some years have 52 and some have 53), but it's probably safe to assume that the NRS data has valid dates.

Invalid week numbers will produce a date in the next year: e.g. week 53 in 2021 would actually start in 2022, which makes it invalid. We can test for that by checking that the year provided is the same year in the date produced.

```{r}
date_first_week_2020 <- ymd("2019-12-30")
ISOweek::ISOweek2date(weekdate = "2019-W53-1")
ISOweek::ISOweek2date(weekdate = "2020-W01-1")
ISOweek::ISOweek2date(weekdate = "2020-W52-1")
ISOweek::ISOweek2date(weekdate = "2020-W53-1")
ISOweek::ISOweek2date(weekdate = "2021-W01-1")
ISOweek::ISOweek2date(weekdate = "2021-W53-1")

compute_start_date_from_week_number <- function(week_number, year_number) {
  ## this assumes a valid week number! There are 52 or 53 weeks in a year
  isoweek_string <- glue::glue("{year_number}-W{str_pad(week_number, width=2, pad='0')}-1")
  computed_dates <- ISOweek::ISOweek2date(isoweek_string)
  ## invalid weeks will result in a computed date in a year after the requested year...
  ## a valid week can result in a date that starts in the year before!
  if (any(year_number<year(ymd(computed_dates)))) stop("invalid week number provided!")
  return(computed_dates)
}

tibble(
    week_number = c(1,2,3,52,53)
  ) %>%
  mutate(
    date = compute_start_date_from_week_number(week_number = week_number, year_number = 2020),
    iso_week_from_date = isoweek(date)
  ) %>% knitr::kable(caption = "Examples of computing start date for each week, and computing isoweek from the dates!")
```


## Recoding dates

```{r}
data_main <- 
  data_raw %>%
  clean_names() %>%
  rename(cause_of_death = causeofdeath, location_of_death = locationofdeath) %>%  # neater names
  filter(!ref_period %in% as.character(2020:2021))  %>% # remove totals for 2020 & 2021
  mutate(
    ref_year = parse_integer(str_extract(ref_period, pattern="^(2020|2021)")),
    week_number = parse_integer(str_remove(ref_period, pattern = "^(2020|2021)\\-")),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = ref_year),
    value = as.numeric(value)  # convert to numeric!
  ) %>%
  select(-c(ref_area, measure_type))  # ref_area is Scotland for all records; measure_type is count

## check date conversion
data_main %>% count(ref_period, date_w_c) %>% slice(1:3, (nrow(.) - 3):nrow(.)) %>% knitr::kable(caption = "Checking the computation of 'date w/c' from year & week number - note how the 1st week of 2020 started in 2019.")
```


# Visualisations

## Number of deaths by age group

```{r, fig.width=12, fig.height=9}
## graph format copied from: https://github.com/davidhen/nrs_covid_stats/

date_range_text <- glue::glue("Data from w/c {format(min(data_main$date_w_c), '%d %B %Y')} to w/c {format(max(data_main$date_w_c), '%d %B %Y')} (inclusive).") 

data_main %>% 
  filter(sex == "all" & location_of_death == "all" & cause_of_death == "covid-19-related") %>% 
  filter(age != "all") %>% 
  group_by(age) %>% 
  summarise(n = sum(value)) %>%
  mutate(pct = round(n/sum(n), 3)) %>% 
  ggplot(aes(age, n)) +
  geom_col(fill = "#4477AA") +
  geom_text(aes(label = scales::percent(pct, accuracy = 0.1), y = n + 80)) +
  theme_minimal() +
  labs(x = "",
       y = "",
       title = "Deaths Associated with COVID-19 by Age Group",
       subtitle = date_range_text,
       caption = "Source: National Records of Scotland\nDeaths where COVID-19 mentioned on the death certificate.")
```

## 