---
title: "Place of death in NRS COVID-19 deaths"
author: "Jan Savinc"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load packages

```{r, warning=FALSE, message=FALSE}
## install packages from github if not yet available!
# remotes::install_github("datasciencescotland/opendatascot", force = TRUE)
# remotes::install_github("Health-SocialCare-Scotland/phsmethods", force = TRUE)

library(tidyverse)  # for tidy workflow
library(opendatascot)  # importing data from ScotGov open data website
library(phsmethods)  # methods for working with PHS data
library(readxl)  # for reading excel files
# library(SPARQL)  # taken care of by opendatascot
library(lubridate)  # dealing with dates
library(janitor)  # for cleaning column names
library(ISOweek)  # for computing date from ISO week number + year
```


# Set up SPARQL query

Note: not needed if using `opendatascot`
To access the latest NRS data using their API, we first setup a SPARQL query.

```{r}
endpoint <- "http://statistics.gov.scot/sparql.json"
```


# Import & wrangle data

We're importing two kinds of data:

1. Weekly deaths involving COVID-19 from Scottish gov't open data service, broken down by week & place of death (home or institution)
2. Historical deaths 2015-2019, grouped by week & place of death

For both of these, we'll also look at crosstabulated figures for:

* Health board
* Local Authority
* Sex
* Age
* ~~Ethnicity~~ Note: not sure this is available

There are two ways of obtaining the data:

1. Using their SPARQL-based API ("data cube"), which can be accessed using the `opendatascot` package in R; the data can be seen on [the Scottish Gov't open data website](https://statistics.gov.scot/data/deaths-involving-coronavirus-covid-19)
2. There are a number of dataset, including the demographic/geographic crosstabulations available on the "Related Statistics" section of the [deaths involving COVID-19 website]( https://www.nrscotland.gov.uk/statistics-and-data/statistics/statistics-by-theme/vital-events/general-publications/weekly-and-monthly-data-on-births-and-deaths/deaths-involving-coronavirus-covid-19-in-scotland)

Note that the [*About* tab of the "data cube" interface](https://statistics.gov.scot/resource?uri=http%3A%2F%2Fstatistics.gov.scot%2Fdata%2Fdeaths-involving-coronavirus-covid-19) says the following about Health Board & Local Authority figures:

>Health Board and Local Authority figures include non-residents. Deaths are allocated to areas based on the usual residence of the deceased. If the deceased was not a Scottish resident, the death is allocated to the area where the death occurred.

This means we'll need to download those figures from the website rather than using the API

Note that the weekly deaths due to COVID-19 in 2020 & 2021 also include a weekly average 2015-2019, but for the purposes of showing the range of deaths (weekly minima & maxima), we need the weekly figures for individual years & the appropriate cross-tabulations.


## Parsing week numbers

In the `opendatascot`-imported data, `refPeriod` refers to the week number (called `week of occurrence` in the `.xlsx`/`.csv`-imported data has), as defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date), and can be computed from a date with `lubridate::isoweek()`; the first week of 2020 is the week starting with Monday 2019-12-30, ~~and the corresponding start dates for each week can be computed by adding weeks using `lubridate::dweeks()` to that date.~~ This is non-trivial, because the number of iso weeks in a year isn't constant. The `ISOweek::ISOweek2date()` function deals with this issue in a crude manner, and allows us to compute the date (w/c on date) from the year & week number. It relies on being provided a valid week number (some years have 52 and some have 53), but it's probably safe to assume that the NRS data has valid dates.

Invalid week numbers will produce a date in the next year: e.g. week 53 in 2021 would actually start in 2022, which makes it invalid. We can test for that by checking that the year provided is the same year in the date produced.

We'll also compute a 'run-over' week number of 2021 in case we plot both years on a contibuous X-axis - in this case, week 1 of 2021 follows week 53 of 2020, so we start counting from 54 in 2021.

```{r}
date_first_week_2020 <- ymd("2019-12-30")
ISOweek::ISOweek2date(weekdate = "2019-W53-1")
ISOweek::ISOweek2date(weekdate = "2020-W01-1")
ISOweek::ISOweek2date(weekdate = "2020-W52-1")
ISOweek::ISOweek2date(weekdate = "2020-W53-1")
ISOweek::ISOweek2date(weekdate = "2021-W01-1")
ISOweek::ISOweek2date(weekdate = "2021-W53-1")

compute_start_date_from_week_number <- function(week_number, year_number) {
  ## this assumes a valid week number! There are 52 or 53 weeks in a year
  isoweek_string <- glue::glue("{year_number}-W{str_pad(week_number, width=2, pad='0')}-1")
  computed_dates <- ISOweek::ISOweek2date(isoweek_string)
  ## invalid weeks will result in a computed date in a year after the requested year...
  ## a valid week can result in a date that starts in the year before!
  if (any(year_number<year(ymd(computed_dates)))) stop("invalid week number provided!")
  return(computed_dates)
}

tibble(
    week_number = c(1,2,3,52,53)
  ) %>%
  mutate(
    date = compute_start_date_from_week_number(week_number = week_number, year_number = 2020),
    iso_week_from_date = isoweek(date)
  ) %>% knitr::kable(caption = "Examples of computing start date for each week, and computing isoweek from the dates!")
```


## Consistent pPlace of death coding

Place of death was named differently between datasets (location/place) and the different places were also named slightly differently, so we find all of them and recode them to the same:

```{r}
order_of_place_of_death_levels <- c("Hospital", "Care home", "Home & other non-institution", "Other", "All")

recode_place_of_death <- function(data_tbl) {
  data_tbl %>%
    mutate(place_of_death = case_when(
      str_detect(place_of_death, pattern = regex(pattern = "all", ignore_case = TRUE)) ~ "All",
      str_detect(place_of_death, pattern = regex(pattern = "care.*home", ignore_case = TRUE)) ~ "Care home",
      str_detect(place_of_death, pattern = regex(pattern = "(non.*institut)|home", ignore_case = TRUE)) ~ "Home & other non-institution",
      str_detect(place_of_death, pattern = regex(pattern = "hospital", ignore_case = TRUE)) ~ "Hospital",
      str_detect(place_of_death, pattern = regex(pattern = "other", ignore_case = TRUE)) ~ "Other",
      TRUE ~ NA_character_
      ) %>%
        factor(x = ., levels = order_of_place_of_death_levels)
    )
}
```


## Consistent Cause of death coding

The `opendatascot`-imported data distinguishes "all causes" deaths from "covid-related" deaths - the non-covid-related deaths are the difference between those. In contrast, the other weekly datasets code cause of death as either covid-related or non-covid-related, in which case we need to compute all cause deaths as the sum of the two.

We'll change the wording of these to a consistent format so it's easier to compute consistent columns. The below function will also compute non-covid deaths for data where all deaths and covid deaths are provided, and all deaths where covid- and non-covid-related deaths are provided.

This involves pivotting the number of deaths variable into wide format based on the cause of death. Because of this, we need to deal with implicit missing values:

The first COVID-19-related deaths were reported from week 12 onwards. In some of the datasets, a missing/omitted value represents 0 cases in that category, when a 0 should have been recorded. E.g. deaths in "Other institutions" are very low, and if a record is missing for that category, we should assume 0 deaths.


```{r}
## helper function to make consistently coded cause of death
recode_cause_of_death <- function(data_tbl) {
  data_tbl %>%
    mutate(
      cause_of_death = case_when(
        cause_of_death == "all-causes" ~ "deaths_all_causes",
        cause_of_death == "all-causes-average-of-corresponding-week-over-previous-5-years" ~ "deaths_nrs_past_average_all_causes",
        cause_of_death == "covid-19-related" ~ "deaths_covid_related",
        cause_of_death == "COVID-19 mentioned" ~ "deaths_covid_related",
        cause_of_death == "Non-COVID-19" ~ "deaths_non_covid",
        TRUE ~ NA_character_
      )
    )
}

## find which combinations of geographic area, cause of death, and place of death are missing and set the number of deaths to 0 for them
complete_weekly_deaths_with_implicit_zeros <- function(data_tbl) {
  data_tbl %>%
  tidyr::complete(
      nesting(year, week_number, week_number_run_over, date_w_c),  # these are 'identifying' variables that shouldn't be combinatorily exploded
      ref_area, cause_of_death, place_of_death,  # these are the variables we want to have all combinations of, and missing combinations are set to 0 deaths
      fill = list(number_of_deaths = 0)
      )
}

## covid death reporting started in week 12, 2020 - before then it doesn't make sense to distunguish between covid and non-covid deaths, and only the all cause death figure should be kept
## by using the 'overrun' weeks we ensure that 2021 or later isn't affected
## note: we're keeping all cause deaths!
set_covid_and_non_covid_deaths_to_zero_before_reporting_started <- function(data_tbl) {
  data_tbl %>%
    mutate(
      deaths_non_covid = if_else(
        condition = week_number_run_over < 12,
        true = NA_real_,
        false = deaths_non_covid
      ),
      deaths_covid_related = if_else(
        condition = week_number_run_over < 12,
        true = NA_real_,
        false = deaths_covid_related
      )
    )
}

# TODO: delete below function, it's too complicated and I've broken it down to the individual functions
# recode_cause_of_death_and_compute_columns <- function(data_tbl) {
#   potential_grouping_variables <- c("ref_area","sex","age","ref_period")
#   grouping_variables <- potential_grouping_variables[which(potential_grouping_variables %in% names(data_tbl))]
#   
#   interim_data_tbl <- 
#     data_tbl %>%
#     recode_cause_of_death() %>%
#     tidyr::complete(
#       nesting(year, week_number, week_number_run_over, date_w_c),
#       !!!rlang::syms(grouping_variables),
#       cause_of_death, place_of_death,
#       fill = list(number_of_deaths = 0)
#       ) %>%
#     pivot_wider(names_from = "cause_of_death", values_from = "number_of_deaths")
#   
#   ## compute non-covid deaths from all deaths minus covid deaths
#   if (!"deaths_non_covid" %in% names(interim_data_tbl)) {
#     interim_data_tbl <-
#       interim_data_tbl %>%
#       mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related)
#   }
#   ## compute all deaths from non-covid deaths + covid deaths
#   if (!"deaths_all_causes" %in% names(interim_data_tbl)) {
#     interim_data_tbl <-
#       interim_data_tbl %>%
#       mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related)
#   }
#   
#   interim_data_tbl <-
#     interim_data_tbl %>%  # set as missing covid- & non-covid-related deaths before week 12
#     mutate(
#       deaths_non_covid = if_else(
#         condition = week_number_run_over < 12,
#         true = NA_real_,
#         false = deaths_non_covid
#       ),
#       deaths_covid_related = if_else(
#         condition = week_number_run_over < 12,
#         true = NA_real_,
#         false = deaths_covid_related
#       )
#     )
#   
#   return(interim_data_tbl)
# }
```


## Consistent use of missing value

```{r}
replace_na_with_0_from_week_12 <- function(data_tbl) {
  data_tbl %>%
    mutate(
      value = if_else(
        condition = week_number_roll_over >=12 & is.na(number_of_deaths),
        true = 0,
        false = number_of_deaths
      )
    )
}
```


## Load weekly COVID-19 related deaths

~~Using `opendatascot` to load weekly deaths the level of geography can be specified, so we can have more or less granular data~~ Choosing a more granular level than Scotland-wide data means place of death is collapsed to the 'all' category only, see note above!

```{r}
# checking out structure

# ods_all_datasets() %>% View()
# ods_structure("deaths")  # can we import all deaths-related data this way?
# ods_print_query("deaths")

# ods_structure("deaths-involving-coronavirus-covid-19")
# ods_schemes("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19", geography = "la")
# ods_find_lower_geographies("S92000003")  # Scotland's refArea = S92000003
# phsmethods::match_area("S92000003")  # "Scotland"

## helper function that links the 9-character geography code to its name
make_human_readable_ref_area <- function(data_tbl, ref_area = refArea) {
  enquoted_ref_area <- enquo(ref_area)
  data_tbl %>%
    mutate(
      !!enquoted_ref_area := phsmethods::match_area(!!enquoted_ref_area)
    )
}

# raw_covid_deaths <- list(
#   scotland = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc"),
#   health_board = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "hb"),
#   local_authority = ods_dataset("deaths-involving-coronavirus-covid-19",geography = "la")
# ) %>%
#   map(.x = ., .f = ~make_human_readable_ref_area(data_tbl = .x))

weekly_deaths_age_sex <-
  ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc") %>%
  make_human_readable_ref_area %>%
  clean_names() %>%
  ## below series of rename operations are a stupid way of dealing with the possibility of different variable name conventions in the ods_dataset data: sometimes they are in snake_case, and sometimes in camelCase, seemingly unpredictably
  rename_at(.vars = vars(matches("location", ignore.case = TRUE)), ~"place_of_death") %>%
  rename_at(.vars = vars(matches("period", ignore.case = TRUE)), ~"ref_period") %>%
  rename_at(.vars = vars(matches("area", ignore.case = TRUE)), ~"ref_area") %>%
  rename_at(.vars = vars(matches("measure", ignore.case = TRUE)), ~"measure_type") %>%
  rename_at(.vars = vars(matches("cause", ignore.case = TRUE)), ~"cause_of_death") %>%
  rename_at(.vars = vars(matches("sex", ignore.case = TRUE)), ~"sex") %>%
  rename_at(.vars = vars(matches("age", ignore.case = TRUE)), ~"age") %>%
  rename_at(.vars = vars(matches("value", ignore.case = TRUE)), ~"number_of_deaths") %>%  # rename so it's consistent with other data
  filter(!ref_period %in% as.character(2020:2021)) %>% # remove totals for 2020 & 2021, we only want the weekly figures
  mutate(
    year = parse_integer(str_extract(ref_period, pattern="^(2020|2021)")),
    week_number = parse_integer(str_remove(ref_period, pattern = "^(2020|2021)\\-")),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    number_of_deaths = as.numeric(number_of_deaths),  # convert to numeric!
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  select(-c(measure_type)) %>%  #  measure_type is count for all data
  recode_place_of_death() %>%
  recode_cause_of_death() %>%
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%  # this dataset is well-formatted and has no implicit missing values!
  mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related)  # compute non-covid deaths from the other two figures - will be NA where either is missing
  

weekly_deaths_la_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-council-area-location.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

weekly_deaths_la <- 
  read_excel(weekly_deaths_la_file, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = council, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  complete_weekly_deaths_with_implicit_zeros() %>%
  recode_place_of_death() %>%  # this needs to be done before recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%   # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()


weekly_deaths_hb_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

weekly_deaths_hb <- 
  read_excel(weekly_deaths_hb_file, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = health_board, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  complete_weekly_deaths_with_implicit_zeros() %>%
  recode_place_of_death() %>%  # this needs to be done before recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%  # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()
```


### Checking week number coding

```{r}
weekly_deaths_age_sex %>% 
  count(ref_period, date_w_c, week_number, week_number_run_over) %>% 
  slice(1:3, (nrow(.) - 3):nrow(.)) %>% 
  select(-n) %>% 
  knitr::kable(caption = "Checking the computation of dates from week numbers - note how the 1st week of 2020 started in 2019.")
```


## Load historical deaths data

The format of the .xlsx files is that sheet 1 is a table of contents, sheet 2 contains the data, and sheet 3 is a pivot table for subsetting data.

```{r, warning=FALSE}
## overall file - where did I get the link from? it's not obviously available from the website...
past_deaths_overall_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files/statistics/covid19/weekly-deaths-by-location-2015-2019.csv",
                destfile = tempfile(),
                quiet = FALSE)

past_deaths_hb_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location-15-19.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

past_deaths_la_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-council-areas.xlsx",
                destfile = tempfile(),
                quiet = FALSE)

past_deaths_age_sex_file <-
  curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-age-group-sex-15-19.xlsx",
                destfile = tempfile(),
                quiet = FALSE)


past_deaths_overall <- 
  read_csv(past_deaths_overall_file, skip = 2) %>%
  rename(year = 1) %>%  # rename first column
  mutate(
    place_of_death = if_else(is.na(`1`), true = year, NA_character_)
  ) %>%
  fill(place_of_death, .direction="down") %>%  # LOCF on place_of_death
  drop_na(`1`) %>%
  pivot_longer(cols = all_of(as.character(1:53)), values_to = "number_of_deaths", names_to = "week_number") %>%
  mutate(week_number=as.integer(week_number)) %>%
  recode_place_of_death()

past_deaths_hb <- 
  readxl::read_excel(past_deaths_health_board_file, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  drop_na(number_of_deaths) %>%  # remove empty rows & one row where it's just the copyright notice
  rename(
    week_number = week_of_occurrence,
    place_of_death = location
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  recode_place_of_death()

past_deaths_la <-
  readxl::read_excel(past_deaths_council_area_file, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  drop_na(number_of_deaths) %>%  # remove empty rows & one row where it's just the copyright notice
  rename(
    week_number = week,
    place_of_death = location_of_death
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  recode_place_of_death()

past_deaths_age_sex <-  # structure here is a bit more complicated - headers in row 3, but sex & age headers in row 4
  readxl::read_excel(past_deaths_age_sex_file, sheet = 2, skip = 4, col_names = c("year","week_number","place_of_death","sex","age","number_of_deaths"), guess_max = 1e5) %>%
  drop_na(number_of_deaths) %>%    # remove empty rows & one row where it's just the copyright notice
  mutate(
    year = 2000L + as.integer(year),
    week_number = as.integer(week_number)
  ) %>%
  recode_place_of_death()

## check that the results are the same as overall deaths
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_health_board, past_deaths_council_area, past_deaths_age_sex),
  .y = c("overall","health_board","council_area","age_sex"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(!is.na(year) & place_of_death!="All locations") %>%
      group_by(dataset,year) %>%
        summarise(total = sum(number_of_deaths), .groups = "drop")
  }
) %>% 
  pivot_wider(names_from=year,values_from=total) %>%
  knitr::kable(caption = "Number of deaths by year as calculated from different datasets. All datasets apart from the split by health board agree. The differences in the health board dataset likely reflect missing values and/or small numbers redacted from the dataset, which may have to do with the grouping of state hospital/non-NHS institutions.")
```


# Calculate historical averages, minima & maxima

Due to the counting of weeks, most years have 52 weeks with some years (2015 & 2020) having 53. Therefore we need to decide how to deal with week 53 in 2020 since only 2015 has a corresponding weekly count. The solution used here is to calculate a weekly rate for week 53 from week 53 in 2015, and week 52 in 2016-2019 - this represents the "last week of the year", which includes December 31st.

```{r, warning=FALSE}
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_hb, past_deaths_la, past_deaths_age_sex),
  .y = c("overall","health_board","council_area","age_sex"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(year %in% 2016:2019 & week_number==53) %>%
      count(dataset,year)
  }
) %>% 
  pivot_wider(names_from=year,values_from=n) %>%
  knitr::kable(caption = "Number of entries by dataset for week number 53 in years 2016-2019 (which only had 52 weeks). Only the 'overall' historical deaths dataset has week 53 entries for years with 52 weeks, and all the entries are for 0 deaths.")

## helper function that creates week 53 data by taking week 52 in years with no year 53 and relabels it as 53
## CAUTION: only use this for computing averages! otherwise it's making up data that wasnae there
create_week_53_data_for_years_with_52_weeks <- function(data_tbl) {
  real_data <-
    data_tbl %>%
    filter(!(year %in% 2016:2019 & week_number==53))  # remove any entries for week 53 in years with 52 weeks - in some datasets they existed but had 0 listed
  fake_data <-
    data_tbl %>%
    filter(year %in% 2016:2019 & week_number==52) %>%
    mutate(week_number=53)
  return(
    bind_rows(
      real_data,
      fake_data
    )
  )
}

# TODO: clean up once these have been dealth with

historical_average_overall <-
  past_deaths_overall %>%
  filter(year!="average") %>%  # remove averages
  group_by(year, week_number) %>%  # remove week 53 if it was 0 for all places  - this means there was no week 53!
  filter(!all(number_of_deaths==0 & week_number==53)) %>%
  ungroup %>%
  create_week_53_data_for_years_with_52_weeks %>%
  ungroup %>%
  group_by(week_number,place_of_death) %>% 
  summarise(
    across(number_of_deaths, .fns = list(mean=mean,min=min,max=max)),
    .groups = "drop"
  ) %>% rename_all(~str_replace_all(.x, pattern = "number_of_deaths", replacement = "deaths"))


week_53_text <- "Due to the way ISO 8601 counts weeks, only 2015 in the 2015-2019 period had 53 weeks; averages for week 53 were computed from figures for week 53 in 2015 and week 52 for 2016-2019."

# TODO: weekly averages may be too detailed for this level od subcategorising!

historical_average_hb <-
  past_deaths_hb %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, health_board
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_la <-
  past_deaths_la %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, council_area
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_age_sex <-
  past_deaths_age_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_age <-
  past_deaths_age_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_sex <-
  past_deaths_age_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )
```


## Check weekly historic averages against NRS computed data

```{r}
weekly_deaths_age_sex %>%
  filter(sex=="all" & age=="all" & cause_of_death=="all-causes-average-of-corresponding-week-over-previous-5-years") %>%
  select(week_number, year = year, place_of_death, nrs_computed_mean = number_of_deaths) %>%
  left_join(historical_average_overall) %>%
  filter(round(nrs_computed_mean) != round(deaths_mean)) %>%
  knitr::kable(caption = "Subset of weekly deaths where calculated mean deaths 2015-2019 differed between the COVID-19 related deaths file and the weekly deaths file. Week 53 was computed as the average of deaths in week 53 in 2015 and week 52 in 2016-2019. For all the other datasets the mean deaths computed agree!")
```


# Merge weekly COVID/non-COVID-related deaths in 2020/2021 with historic death rates

```{r}
merged_data_overall <-
  weekly_deaths_age_sex %>%
  filter(sex=="all" & age=="all") %>%
  # covid_deaths$scotland %>%
  split_deaths_due_to_covid_and_not %>%
  left_join(historical_average_overall %>% mutate(sex = "all", age = "all"),  # only merge for aggregated data b/c that's all we have!
            by = c("place_of_death", "week_number", "sex", "age"))


# TODO: complete these for age & sex also
merged_deaths_hb <-
  weekly_deaths_hb %>%
  inner_join(historical_average_hb, by = c("week_number","ref_area"="health_board","place_of_death"))

merged_deaths_la <-
  weekly_deaths_la %>%
  inner_join(historical_average_la, by = c("week_number","ref_area"="council_area","place_of_death"))


# merged_deaths_by_age_sex <-
#   deaths_by_cause %>%
#   split_deaths_due_to_covid_and_not %>%
#   left_join(historical_range_by_age_sex) %>%
#   compute_run_over_week_for_2021
# 
# merged_deaths_by_age <-
#   deaths_by_cause %>%
#   split_deaths_due_to_covid_and_not %>%
#   left_join(historical_range_by_age) %>%
#   compute_run_over_week_for_2021
# 
# merged_deaths_by_sex <-
#   deaths_by_cause %>%
#   split_deaths_due_to_covid_and_not %>%
#   left_join(historical_range_by_sex) %>%
#   compute_run_over_week_for_2021
```



# Visualisations

## Common elements

```{r}
date_range_text <- glue::glue("Data from w/c {format(min(deaths_by_cause$date_w_c), '%d %B %Y')} to w/c {format(max(deaths_by_cause$date_w_c), '%d %B %Y')} (inclusive).") 

source_nrs_text <- "Source: National Records of Scotland"
```



## Number of deaths by age group

```{r, fig.width=12, fig.height=9}
## graph format copied from: https://github.com/davidhen/nrs_covid_stats/
deaths_by_cause %>% 
  filter(sex == "all" & place_of_death == "all" & cause_of_death == "covid-19-related") %>% 
  filter(age != "all") %>% 
  group_by(age) %>% 
  summarise(n = sum(number_of_deaths)) %>%
  mutate(pct = round(n/sum(n), 3)) %>% 
  ggplot(aes(age, n)) +
  geom_col(fill = "#4477AA") +
  geom_text(aes(label = scales::percent(pct, accuracy = 0.1), y = n + 80)) +
  theme_minimal() +
  labs(x = "",
       y = "",
       title = "Deaths Associated with COVID-19 by Age Group",
       subtitle = date_range_text,
       caption = paste0(c(date_range_text,source_nrs_text), collapse="\n")
  )
```


## Figure 6: Recorded deaths in Scotland, by week number & location

```{r, fig.width=12, fig.height=9}
vertical_line_text <- "Vertical dotted line at week number 54 represents start of 2021."

removed_other_category_text <- glue::glue("Excluding 'Other' institutional place of death, N={merged_data_overall %>% filter(sex == 'all' & age == 'all' & place_of_death_recoded == 'Other') %>% .$deaths_all_causes %>% sum} for weeks 1-{max(merged_data_overall %>% filter(year==2020) %>% .$week_number)} in 2020 and 1-{max(merged_data_overall %>% filter(year==2021) %>% .$week_number)} in 2021.")

annotations_figure_6 <-
# datapasta::tribble_paste(tbl_recoded_place_of_death %>% select(place_of_death_recoded))
  tibble::tribble(
    ~place_of_death_recoded, ~x, ~y, ~label,
                 "Hospital", 20L, 850, "Shaded area shows range of 2015-2019 deaths; dashed line shows weekly average",
                 "Hospital", 25L, 250, "Hospital deaths dipped below historical minimum and remained low until Winter.",
                "Care home", 35L, 500, "After initial peak, deaths returned to historical range; non-Covid deaths remained low.",
                     "Home", 35L, 500, "The gap between historical high and both types of death at home was high throughout."
                  ) %>% 
  mutate(
    place_of_death_recoded = factor(place_of_death_recoded, levels = levels(tbl_recoded_place_of_death$place_of_death_recoded)),  # needs to be factor with same levels, otherwise it messes up level order when added as geom_text later!
    label = str_wrap(label, width = 40)
    )

# figure_6_location_of_death <-
  merged_data_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(!place_of_death_recoded %in% c("All","Other")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid_related), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  geom_text(data = annotations_figure_6, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~place_of_death_recoded) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

map(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_6_location_of_death",.x), plot = figure_6_location_of_death, width = 12, height = 9, dpi = 300)
)

figure_6_location_of_death
```


## Figure 7: deaths at home

```{r}
# TODO

```


## Figure 8: deaths at home, by health board

```{r}
# TODO: fix this once we have health board in weekly deaths!
merged_deaths_hb %>%
  # filter(sex == "all" & age == "all") %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  # geom_text(data = annotations_figure_6, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       # caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )


merged_deaths_la %>%
  # filter(sex == "all" & age == "all") %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  # geom_text(data = annotations_figure_6, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       # caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )


```


## Figure 10: deaths at home by sex

```{r}
merged_deaths_by_sex %>%
  filter(sex != "all" & age == "all") %>%
  filter(place_of_death_recoded == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid_related), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  # geom_text(data = annotations_figure_6, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~sex) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       # caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )
```

