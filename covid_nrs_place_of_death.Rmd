---
title: "Place of death in NRS COVID-19 deaths"
author: "Jan Savinc"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
params:
  data_sources: '`r tibble()`'
  historical_data_sources: '`r tibble()`'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load packages

```{r, warning=FALSE, message=FALSE}
## install packages from github if not yet available!
# remotes::install_github("datasciencescotland/opendatascot", force = TRUE)
# remotes::install_github("Health-SocialCare-Scotland/phsmethods", force = TRUE)

library(tidyverse)  # for tidy workflow
library(opendatascot)  # importing data from ScotGov open data website
library(phsmethods)  # methods for working with PHS data
library(readxl)  # for reading excel files
# library(SPARQL)  # taken care of by opendatascot
library(lubridate)  # dealing with dates
library(janitor)  # for cleaning column names
library(ISOweek)  # for computing date from ISO week number + year
library(sf)  # for mapping
```


# Set up SPARQL query

Note: not needed if using `opendatascot`
To access the latest NRS data using their API, we first setup a SPARQL query.

```{r}
endpoint <- "http://statistics.gov.scot/sparql.json"
```


# Copyright attribution

All data used for this study were obtained from the National Records Scotland (NRS) and are Â© Crown copyright, 2020; the details of the licence can be viewed on the [Open Government Licence website](http://www.nationalarchives.gov.uk/doc/open-government-licence/open-government-licence.htm)


# Dates represent event registration, not occurrence!

From NRS website:

> All routine vital events information we publish is based on the date of registration, not the date on which the event occurred. Inevitably, of course, there are delays between the occurrence of an event and its registration.


# Context of lockdowns

A recent timeline of COVID-19 events in Scotland is [available here](https://spice-spotlight.scot/2021/01/29/timeline-of-coronavirus-covid-19-in-scotland/). Including these might help in the interpreration fo the figures, though the figures are already pretty busy. This is a potential future TODO!


# Import & wrangle data

We're importing two kinds of data:

1. Weekly deaths involving COVID-19 from Scottish gov't open data service, broken down by week & place of death (home or institution)
2. Historical deaths 2015-2019, grouped by week & place of death

For both of these, we'll also look at crosstabulated figures for:

* Health board
* Local Authority
* Sex
* Age
* ~~Ethnicity~~ *Note: not sure this is available*

There are two ways of obtaining the data:

1. ~~Using their SPARQL-based API ("data cube"), which can be accessed using the `opendatascot` package in R; the data can be seen on [the Scottish Gov't open data website](https://statistics.gov.scot/data/deaths-involving-coronavirus-covid-19)~~
    - Update: it's difficult to keep track of data updates using the API - it's simpler to query the .xlsx/.csv files (next bullet point) for when they were last modified and download the weekly update once it's been released!
2. There are a number of datasets, including the demographic/geographic crosstabulations available on the "Related Statistics" section of the [deaths involving COVID-19 website]( https://www.nrscotland.gov.uk/statistics-and-data/statistics/statistics-by-theme/vital-events/general-publications/weekly-and-monthly-data-on-births-and-deaths/deaths-involving-coronavirus-covid-19-in-scotland), under the *Ad-hoc queries section*. They are updated weekly, and also contain historical figures.

Note that the [*About* tab of the "data cube" interface](https://statistics.gov.scot/resource?uri=http%3A%2F%2Fstatistics.gov.scot%2Fdata%2Fdeaths-involving-coronavirus-covid-19) says the following about Health Board & Local Authority figures:

>Health Board and Local Authority figures include non-residents. Deaths are allocated to areas based on the usual residence of the deceased. If the deceased was not a Scottish resident, the death is allocated to the area where the death occurred.

This means we'll need to download those figures from the website rather than using the API!

Note that the weekly deaths due to COVID-19 in 2020 & 2021 also include a weekly average 2015-2019, but for the purposes of showing the range of deaths (weekly minima & maxima), we need the weekly figures for individual years & the appropriate cross-tabulations.

```{r}
# "unpack" the data source tables
table_of_data_sources <- params$data_sources
table_of_historical_data_sources <- params$historical_data_sources

table_of_data_sources %>%
  kable(caption = "Latest data used in this report.")
```


## Parsing week numbers

In the `opendatascot`-imported data, `refPeriod` refers to the week number (called `week of occurrence` in the `.xlsx`/`.csv`-imported data has), as defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date), and can be computed from a date with `lubridate::isoweek()`; the first week of 2020 is the week starting with Monday 2019-12-30, ~~and the corresponding start dates for each week can be computed by adding weeks using `lubridate::dweeks()` to that date.~~ This is non-trivial, because the number of iso weeks in a year isn't constant. The `ISOweek::ISOweek2date()` function deals with this issue in a crude manner, and allows us to compute the date (w/c on date) from the year & week number. It relies on being provided a valid week number (some years have 52 and some have 53), but it's probably safe to assume that the NRS data has valid dates.

Invalid week numbers will produce a date in the next year: e.g. week 53 in 2021 would actually start in 2022, which makes it invalid. We can test for that by checking that the year provided is the same year in the date produced.

We'll also compute a 'run-over' week number of 2021 in case we plot both years on a contibuous X-axis - in this case, week 1 of 2021 follows week 53 of 2020, so we start counting from 54 in 2021.

```{r}
date_first_week_2020 <- ymd("2019-12-30")
ISOweek::ISOweek2date(weekdate = "2019-W53-1")
ISOweek::ISOweek2date(weekdate = "2020-W01-1")
ISOweek::ISOweek2date(weekdate = "2020-W52-1")
ISOweek::ISOweek2date(weekdate = "2020-W53-1")
ISOweek::ISOweek2date(weekdate = "2021-W01-1")
ISOweek::ISOweek2date(weekdate = "2021-W53-1")

compute_start_date_from_week_number <- function(week_number, year_number) {
  ## this assumes a valid week number! There are 52 or 53 weeks in a year
  isoweek_string <- glue::glue("{year_number}-W{str_pad(week_number, width=2, pad='0')}-1")
  computed_dates <- ISOweek::ISOweek2date(isoweek_string)
  ## invalid weeks will result in a computed date in a year after the requested year...
  ## a valid week can result in a date that starts in the year before!
  if (any(year_number<year(ymd(computed_dates)))) stop("invalid week number provided!")
  return(computed_dates)
}

tibble(
    week_number = c(1,2,3,52,53)
  ) %>%
  mutate(
    date = compute_start_date_from_week_number(week_number = week_number, year_number = 2020),
    iso_week_from_date = isoweek(date)
  ) %>% knitr::kable(caption = "Examples of computing start date for each week, and computing isoweek from the dates!")
```


## Consistent Place of death coding

Place of death was named differently between datasets (location/place) and the different places were also named slightly differently, so we find all of them and recode them to the same:

```{r}
order_of_place_of_death_levels <- c("Hospital", "Care home", "Home & other non-institution", "Other", "All")

recode_place_of_death <- function(data_tbl) {
  data_tbl %>%
    mutate(place_of_death = case_when(
      str_detect(place_of_death, pattern = regex(pattern = "all", ignore_case = TRUE)) ~ "All",
      str_detect(place_of_death, pattern = regex(pattern = "care.*home", ignore_case = TRUE)) ~ "Care home",
      str_detect(place_of_death, pattern = regex(pattern = "(non.*institut)|home", ignore_case = TRUE)) ~ "Home & other non-institution",
      str_detect(place_of_death, pattern = regex(pattern = "hospital", ignore_case = TRUE)) ~ "Hospital",
      str_detect(place_of_death, pattern = regex(pattern = "other", ignore_case = TRUE)) ~ "Other",
      TRUE ~ NA_character_
      ) %>%
        factor(x = ., levels = order_of_place_of_death_levels)
    )
}
```


## Consistent Cause of death coding

The `opendatascot`-imported data distinguishes "all causes" deaths from "covid-related" deaths - the non-covid-related deaths are the difference between those. In contrast, the other weekly datasets code cause of death as either covid-related or non-covid-related, in which case we need to compute all cause deaths as the sum of the two.

We'll change the wording of these to a consistent format so it's easier to compute consistent columns. The below function will also compute non-covid deaths for data where all deaths and covid deaths are provided, and all deaths where covid- and non-covid-related deaths are provided.

This involves pivotting the number of deaths variable into wide format based on the cause of death. Because of this, we need to deal with implicit missing values:

The first COVID-19-related deaths were reported from week 12 onwards. In some of the datasets, a missing/omitted value represents 0 cases in that category, when a 0 should have been recorded. E.g. deaths in "Other institutions" are very low, and if a record is missing for that category, we should assume 0 deaths.

On 3 Februrary 2021 as I was updating the script, the weekly figures started distinguishing cause of death: COVID-19 can be a contributory factor, or an underlying cause of death. For the purposes of this study, COVID-19 deaths are in the minority, and we will disregard this distinction for now.


```{r}
## helper function to make consistently coded cause of death
recode_cause_of_death <- function(data_tbl) {
  data_tbl %>%
    mutate(
      cause_of_death = case_when(
        cause_of_death == "all-causes" ~ "deaths_all_causes",
        cause_of_death == "all-causes-average-of-corresponding-week-over-previous-5-years" ~ "deaths_nrs_past_average_all_causes",
        cause_of_death == "covid-19-related" ~ "deaths_covid_related",
        cause_of_death == "COVID-19 mentioned" ~ "deaths_covid_related",
        cause_of_death == "COVID-19 contributory factor" ~ "deaths_covid_related",
        cause_of_death == "COVID-19 underlying cause" ~ "deaths_covid_related",
        cause_of_death == "Non-COVID-19" ~ "deaths_non_covid",
        TRUE ~ NA_character_
      )
    )
}

# TODO:  still too complicated to safely use as a function...
## find which combinations of geographic area, cause of death, and place of death are missing and set the number of deaths to 0 for them
# complete_weekly_deaths_with_implicit_zeros <- function(data_tbl) {
#   data_tbl %>%
#   tidyr::complete(
#       nesting(year, week_number, week_number_run_over, date_w_c),  # these are 'identifying' variables that shouldn't be combinatorily exploded
#       ref_area, cause_of_death, place_of_death,  # these are the variables we want to have all combinations of, and missing combinations are set to 0 deaths
#       fill = list(number_of_deaths = 0)
#       )
# }

## calculate number of deaths after recoding cause of death -
## recoding results in two entries for covid-related deaths, so we need to sum over them
## this is achieved by grouping over all variables other than number of deaths
recalculate_number_of_deaths_after_recoding_cause_of_death <- function(data_tbl) {
  data_tbl %>%
  group_by_all %>% 
  ungroup(number_of_deaths) %>%  # this is done by grouping over everything except the number of deaths
  summarise(number_of_deaths = sum(number_of_deaths), .groups = "drop")  # recompute the sum of deaths
}

## covid death reporting started in week 12, 2020 - before then it doesn't make sense to distunguish between covid and non-covid deaths, and only the all cause death figure should be kept
## by using the 'overrun' weeks we ensure that 2021 or later isn't affected
## note: we're keeping all cause deaths!
set_covid_and_non_covid_deaths_to_zero_before_reporting_started <- function(data_tbl) {
  data_tbl %>%
    mutate(
      deaths_non_covid = if_else(
        condition = week_number_run_over < 12,
        true = NA_real_,
        false = deaths_non_covid
      ),
      deaths_covid_related = if_else(
        condition = week_number_run_over < 12,
        true = NA_real_,
        false = deaths_covid_related
      )
    )
}

# TODO: delete below function, it's too complicated and I've broken it down to the individual functions
# recode_cause_of_death_and_compute_columns <- function(data_tbl) {
#   potential_grouping_variables <- c("ref_area","sex","age","ref_period")
#   grouping_variables <- potential_grouping_variables[which(potential_grouping_variables %in% names(data_tbl))]
#   
#   interim_data_tbl <- 
#     data_tbl %>%
#     recode_cause_of_death() %>%
#     tidyr::complete(
#       nesting(year, week_number, week_number_run_over, date_w_c),
#       !!!rlang::syms(grouping_variables),
#       cause_of_death, place_of_death,
#       fill = list(number_of_deaths = 0)
#       ) %>%
#     pivot_wider(names_from = "cause_of_death", values_from = "number_of_deaths")
#   
#   ## compute non-covid deaths from all deaths minus covid deaths
#   if (!"deaths_non_covid" %in% names(interim_data_tbl)) {
#     interim_data_tbl <-
#       interim_data_tbl %>%
#       mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related)
#   }
#   ## compute all deaths from non-covid deaths + covid deaths
#   if (!"deaths_all_causes" %in% names(interim_data_tbl)) {
#     interim_data_tbl <-
#       interim_data_tbl %>%
#       mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related)
#   }
#   
#   interim_data_tbl <-
#     interim_data_tbl %>%  # set as missing covid- & non-covid-related deaths before week 12
#     mutate(
#       deaths_non_covid = if_else(
#         condition = week_number_run_over < 12,
#         true = NA_real_,
#         false = deaths_non_covid
#       ),
#       deaths_covid_related = if_else(
#         condition = week_number_run_over < 12,
#         true = NA_real_,
#         false = deaths_covid_related
#       )
#     )
#   
#   return(interim_data_tbl)
# }
```


## Consistent use of missing value

```{r}
replace_na_with_0_from_week_12 <- function(data_tbl) {
  data_tbl %>%
    mutate(
      value = if_else(
        condition = week_number_roll_over >=12 & is.na(number_of_deaths),
        true = 0,
        false = number_of_deaths
      )
    )
}
```


## Merging health boards

Smaller health boards were merged... TODO!

> "Note: Orkney, Shetland, & Western health boards were merged into 'Island HBs'; Borders & Dumfries and Galloway health boards were merged into 'B,D&G HB'"

## Load weekly COVID-19 related deaths

~~Using `opendatascot` to load weekly deaths the level of geography can be specified, so we can have more or less granular data~~ Choosing a more granular level than Scotland-wide data means place of death is collapsed to the 'all' category only, see note above! Even for the Scotland-wide data, place of death is collapsed to 'All' for the granular sex & age categories, actually.

```{r}
download_dir <- "./downloaded_data"
if (!dir.exists(download_dir)) dir.create(download_dir)  # create download dir if it doesn't exist

files_weekly_deaths <- set_names(x = as.list(table_of_data_sources$path_latest), nm = table_of_data_sources$short_name)

# checking out structure

# ods_all_datasets() %>% View()
# ods_structure("deaths")  # can we import all deaths-related data this way?
# ods_print_query("deaths")

# ods_structure("deaths-involving-coronavirus-covid-19")
# ods_schemes("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19", geography = "la")
# ods_find_lower_geographies("S92000003")  # Scotland's refArea = S92000003
# phsmethods::match_area("S92000003")  # "Scotland"

## helper function that links the 9-character geography code to its name
make_human_readable_ref_area <- function(data_tbl, ref_area = refArea) {
  enquoted_ref_area <- enquo(ref_area)
  data_tbl %>%
    mutate(
      !!enquoted_ref_area := phsmethods::match_area(!!enquoted_ref_area)
    )
}

# raw_covid_deaths <- list(
#   scotland = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc"),
#   health_board = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "hb"),
#   local_authority = ods_dataset("deaths-involving-coronavirus-covid-19",geography = "la")
# ) %>%
#   map(.x = ., .f = ~make_human_readable_ref_area(data_tbl = .x))

weekly_deaths_overall <-
  ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc") %>%
  make_human_readable_ref_area %>%
  clean_names() %>%
  ## below series of rename operations are a stupid way of dealing with the possibility of different variable name conventions in the ods_dataset data: sometimes they are in snake_case, and sometimes in camelCase, seemingly unpredictably
  rename_at(.vars = vars(matches("location", ignore.case = TRUE)), ~"place_of_death") %>%
  rename_at(.vars = vars(matches("period", ignore.case = TRUE)), ~"ref_period") %>%
  rename_at(.vars = vars(matches("area", ignore.case = TRUE)), ~"ref_area") %>%
  rename_at(.vars = vars(matches("measure", ignore.case = TRUE)), ~"measure_type") %>%
  rename_at(.vars = vars(matches("cause", ignore.case = TRUE)), ~"cause_of_death") %>%
  rename_at(.vars = vars(matches("sex", ignore.case = TRUE)), ~"sex") %>%
  rename_at(.vars = vars(matches("age", ignore.case = TRUE)), ~"age") %>%
  rename_at(.vars = vars(matches("value", ignore.case = TRUE)), ~"number_of_deaths") %>%  # rename so it's consistent with other data
  filter(!ref_period %in% as.character(2020:2021)) %>% # remove totals for 2020 & 2021, we only want the weekly figures
  mutate(
    year = parse_integer(str_extract(ref_period, pattern="^(2020|2021)")),
    week_number = parse_integer(str_remove(ref_period, pattern = "^(2020|2021)\\-")),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    number_of_deaths = as.numeric(number_of_deaths),  # convert to numeric!
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  select(-c(measure_type)) %>%  #  measure_type is count for all data
  recode_place_of_death() %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # not needed here probably, but no harm in including it
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%  # this dataset is well-formatted and has no implicit missing values!
  mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related)  # compute non-covid deaths from the other two figures - will be NA where either is missing
  

# weekly_deaths_sex_age_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-age-sex.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)


weekly_deaths_sex_age <-  # structure here is a bit more complicated - headers in row 3, but sex & age headers in row 4
  readxl::read_excel(files_weekly_deaths$sex_age, sheet = 2, skip = 4, col_names = c("week_number","place_of_death","sex","age","cause_of_death","number_of_deaths"), guess_max = 1e5) %>%
  drop_na(number_of_deaths) %>%    # remove empty rows & one row where it's just the copyright notice
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # recompute the sum of deaths
  tidyr::complete(  # complete implicit missing entries and make them 0
    nesting(week_number,week_number_run_over,date_w_c,year),
    age,sex,place_of_death,cause_of_death,
    fill = list(number_of_deaths = 0)
  ) %>%
  recode_place_of_death() %>%  # this needs to be done after recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%   # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()

# 
# weekly_deaths_la_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-council-area-location.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)

weekly_deaths_la <- 
  read_excel(files_weekly_deaths$la, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = council, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # recompute the sum of deaths
  tidyr::complete(
      nesting(year, week_number, week_number_run_over, date_w_c),  # these are 'identifying' variables that shouldn't be combinatorily exploded
      ref_area, cause_of_death, place_of_death,  # these are the variables we want to have all combinations of, and missing combinations are set to 0 deaths
      fill = list(number_of_deaths = 0)
      ) %>%
  # complete_weekly_deaths_with_implicit_zeros() %>%
  recode_place_of_death() %>%  # this needs to be done before recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%   # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()


# weekly_deaths_hb_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)

weekly_deaths_hb <- 
  read_excel(files_weekly_deaths$hb, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = health_board, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # recompute the sum of deaths
  tidyr::complete(
      nesting(year, week_number, week_number_run_over, date_w_c),  # these are 'identifying' variables that shouldn't be combinatorily exploded
      ref_area, cause_of_death, place_of_death,  # these are the variables we want to have all combinations of, and missing combinations are set to 0 deaths
      fill = list(number_of_deaths = 0)
      ) %>%
  # complete_weekly_deaths_with_implicit_zeros() %>%
  recode_place_of_death() %>%  # this needs to be done before recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%  # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()

## compute weekly data for sex and age separately
## sum over sex or age, respectively
weekly_deaths_sex <-
  weekly_deaths_sex_age %>%
  filter(age!="all") %>%
  group_by(week_number, week_number_run_over, year, date_w_c, sex, place_of_death) %>%
  summarise(across(starts_with("deaths_"), ~sum(.x)), .groups = "drop")

weekly_deaths_age <-
  weekly_deaths_sex_age %>%
  filter(sex!="all") %>%
  group_by(week_number, week_number_run_over, year, date_w_c, age, place_of_death) %>%
  summarise(across(starts_with("deaths_"), ~sum(.x)), .groups = "drop")
```


### Checking week number coding

```{r}
weekly_deaths_overall %>% 
  count(ref_period, date_w_c, week_number, week_number_run_over) %>% 
  slice(1:3, (nrow(.) - 3):nrow(.)) %>% 
  select(-n) %>% 
  knitr::kable(caption = "Checking the computation of dates from week numbers - note how the 1st week of 2020 started in 2019.")
```


## Load historical deaths data

The format of the .xlsx files is that sheet 1 is a table of contents, sheet 2 contains the data, and sheet 3 is a pivot table for subsetting data.

```{r, warning=FALSE}
files_historical_deaths <- set_names(x = as.list(table_of_historical_data_sources$path_latest), nm = table_of_historical_data_sources$short_name)


## overall file - where did I get the link from? it's not obviously available from the website...
# past_deaths_overall_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files/statistics/covid19/weekly-deaths-by-location-2015-2019.csv",
#                 destfile = tempfile(),
#                 quiet = FALSE)
# 
# past_deaths_hb_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location-15-19.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)
# 
# past_deaths_la_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-council-areas.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)
# 
# past_deaths_sex_age_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-age-group-sex-15-19.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)

past_deaths_overall <- 
  read_csv(files_historical_deaths$overall, skip = 2) %>%
  rename(year = 1) %>%  # rename first column
  mutate(
    place_of_death = if_else(is.na(`1`), true = year, NA_character_)
  ) %>%
  fill(place_of_death, .direction="down") %>%  # LOCF on place_of_death
  drop_na(`1`) %>%
  pivot_longer(cols = all_of(as.character(1:53)), values_to = "number_of_deaths", names_to = "week_number") %>%
  mutate(week_number=as.integer(week_number)) %>%
  recode_place_of_death()

past_deaths_hb <- 
  readxl::read_excel(files_historical_deaths$hb, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  drop_na(number_of_deaths) %>%  # remove empty rows & one row where it's just the copyright notice
  rename(  # same format as current data
    week_number = matches("week"),
    place_of_death = matches("location"),
    ref_area = health_board
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  tidyr::complete(
    nesting(week_number,year),  # unique combinations that we don't want to combinatorily explode
    ref_area, place_of_death,  # fill in missing combinations of hb & pod with 0 deaths
    fill = list(number_of_deaths = 0)
  ) %>% 
  recode_place_of_death()  # recode place of death after completing missing combinations, otherwise the factor level "All" gets exploded also

past_deaths_la <-
  readxl::read_excel(files_historical_deaths$la, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  drop_na(number_of_deaths) %>%  # remove empty rows & one row where it's just the copyright notice
  rename(  # same format as current data
    week_number = matches("week"),
    place_of_death = matches("location"),
    ref_area = council_area
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  tidyr::complete(
    nesting(week_number,year),  # unique combinations that we don't want to combinatorily explode
    ref_area, place_of_death,  # fill in missing combinations of la & pod with 0 deaths
    fill = list(number_of_deaths = 0)
  ) %>% 
  recode_place_of_death()  # recode place of death after completing missing combinations, otherwise the factor level "All" gets exploded also

past_deaths_sex_age <-  # structure here is a bit more complicated - headers in row 3, but sex & age headers in row 4
  readxl::read_excel(files_historical_deaths$sex_age, sheet = 2, skip = 4, col_names = c("year","week_number","place_of_death","sex","age","number_of_deaths"), guess_max = 1e5) %>%
  drop_na(number_of_deaths) %>%    # remove empty rows & one row where it's just the copyright notice
  mutate(
    year = 2000L + as.integer(year),
    week_number = as.integer(week_number)
  ) %>%
  tidyr::complete(
    nesting(week_number,year),  # unique combinations that we don't want to combinatorily explode
    sex, age, place_of_death,  # fill in missing combinations of age, sex, pod, with 0 deaths
    fill = list(number_of_deaths = 0)
  ) %>% 
  recode_place_of_death()

## compute weekly data for sex and age separately
## sum over sex or age, respectively
past_deaths_sex <-
  past_deaths_sex_age %>%
  group_by_all %>%
  ungroup(age, number_of_deaths) %>%  # this is done by grouping over everything except the number of deaths & sex
  summarise(number_of_deaths = sum(number_of_deaths), .groups = "drop")

past_deaths_age <-
  past_deaths_sex_age %>%
  group_by_all %>%
  ungroup(sex, number_of_deaths) %>%  # this is done by grouping over everything except the number of deaths & sex
  summarise(number_of_deaths = sum(number_of_deaths), .groups = "drop")
```


### Do we get the same number of deaths between datasets?

```{r}
## check that the results are the same as overall deaths
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_hb, past_deaths_hb, past_deaths_sex_age),
  .y = c("overall","health_board","council_area","sex_age"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(!is.na(year) & place_of_death!="All") %>%
      group_by(dataset,year) %>%
        summarise(total = sum(number_of_deaths), .groups = "drop")
  }
) %>% 
  pivot_wider(names_from=year,values_from=total) %>%
  knitr::kable(caption = "Number of historical deaths by year as calculated from different datasets. The overall dataset and age/sex breakdown agree in figures, and the HB and LA breakdowns agree, but the two pairs differ from each other. The difference is in both directions, some years there are more deaths recorded in one pair, and some years in the other. This may be due to the following (verbatim from data description online): Health Board and Local Authority figures include non-residents. Deaths are allocated to areas based on the usual residence of the deceased. If the deceased was not a Scottish resident, the death is allocated to the area where the death occurred.")
```


## Load map data with `sf`

I previously downloaded shapefiles for:

* Local Authority Districts (LAD) for 2020 (BUC-level resolution): https://geoportal.statistics.gov.uk/datasets/local-authority-districts-may-2020-boundaries-uk-buc
* Health Boards https://data.gov.uk/dataset/27d0fe5f-79bb-4116-aec9-a8e565ff756a/nhs-health-boards
  - Note: this is a fairly high resolution, don't need this much detail!
  - I found a discussion of this on [a github covid-related project](https://github.com/tomwhite/covid-19-uk-data/issues/18#issuecomment-622353841), and user **robchallen** produced a zip file containing [UK-wide health board boundaries](https://github.com/tomwhite/covid-19-uk-data/files/4563933/UK_covid_reporting_regions.zip)


```{r}
# shapefile_hb <- st_read(dsn = "./map_data/hb")  # too detailed!
shapefile_hb_uk_wide <- st_read(dsn = "./map_data/hb_uk_wide/UK_covid_reporting_regions")
shapefile_la <- st_read(dsn = "./map_data/la")

# merged_deaths_la %>%
#   filter(week_number==53 & place_of_death=="Home & other non-institution") %>%
#   left_join(shapefile_la,by=c("ref_area"="lad19nm")) %>%
#   ggplot(aes(fill = deaths_all_causes, geometry = geometry, group=ref_area)) +
#   geom_sf()
# 
# merged_deaths_hb %>%
#   filter(week_number==53 & place_of_death=="Home & other non-institution") %>%
#   left_join(shapefile_hb_uk_wide,by=c("ref_area"="name")) %>%
#   ggplot(aes(fill = deaths_all_causes, geometry = geometry)) +
#   geom_sf() +
#   theme(aspect.ratio = 1.3)

# ggplot(data = shapefile_hb_uk_wide, aes(geometry=geometry)) + geom_sf()
  
## simple UK map
# ggplot(data = map_data(map = "world", region = "UK"), aes(x=long, y = lat, group = group)) +
#   geom_polygon() +
#   coord_map()
```


# Calculate historical averages, minima & maxima

Due to the counting of weeks, most years have 52 weeks with some years (2015 & 2020) having 53. Therefore we need to decide how to deal with week 53 in 2020 since only 2015 has a corresponding weekly count. The solution used here is to calculate a weekly rate for week 53 from week 53 in 2015, and week 52 in 2016-2019 - this represents the "last week of the year", which includes December 31st.

```{r, warning=FALSE}
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_hb, past_deaths_la, past_deaths_sex_age),
  .y = c("overall","health_board","council_area","sex_age"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(year %in% 2016:2019 & week_number==53) %>%
      count(dataset,year)
  }
) %>% 
  pivot_wider(names_from=year,values_from=n) %>%
  knitr::kable(caption = "Number of entries by dataset for week number 53 in years 2016-2019 (which only had 52 weeks). Only the 'overall' historical deaths dataset has week 53 entries for years with 52 weeks, and all the entries are for 0 deaths.")

## helper function that creates week 53 data by taking week 52 in years with no year 53 and relabels it as 53
## CAUTION: only use this for computing averages! otherwise it's making up data that wasnae there
create_week_53_data_for_years_with_52_weeks <- function(data_tbl) {
  real_data <-
    data_tbl %>%
    filter(!(year %in% 2016:2019 & week_number==53))  # remove any entries for week 53 in years with 52 weeks - in some datasets they existed but had 0 listed
  fake_data <-
    data_tbl %>%
    filter(year %in% 2016:2019 & week_number==52) %>%
    mutate(week_number=53)
  return(
    bind_rows(
      real_data,
      fake_data
    )
  )
}

historical_average_overall <-
  past_deaths_overall %>%
  filter(year!="average") %>%  # remove averages
  group_by(year, week_number) %>%  # remove week 53 if it was 0 for all places  - this means there was no week 53!
  filter(!all(number_of_deaths==0 & week_number==53)) %>%
  ungroup %>%
  create_week_53_data_for_years_with_52_weeks %>%
  ungroup %>%
  group_by(week_number,place_of_death) %>% 
  summarise(
    across(number_of_deaths, .fns = list(mean=mean,min=min,max=max)),
    .groups = "drop"
  ) %>% rename_all(~str_replace_all(.x, pattern = "number_of_deaths", replacement = "deaths"))


week_53_text <- "Due to the way ISO 8601 counts weeks, only 2015 in the 2015-2019 period had 53 weeks; averages for week 53 were computed from figures for week 53 in 2015 and week 52 for 2016-2019."

# TODO: weekly averages may be too detailed for this level od subcategorising!

historical_average_hb <-
  past_deaths_hb %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, ref_area
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_la <-
  past_deaths_la %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, ref_area
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_sex_age <-
  past_deaths_sex_age %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_age <-
  past_deaths_age %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_sex <-
  past_deaths_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

compute_historical_annual_average_deaths <- function(data_tbl, ...) {
  grouping_vars <- enquos(...)
  data_tbl %>%
    group_by(year, place_of_death, !!!grouping_vars) %>%
    summarise(  # calculate annual totals first...
    number_of_deaths = sum(number_of_deaths), 
    .groups = "keep"
  ) %>%
  ungroup(year) %>%  # remove year as grouping to average over year now
  summarise(
    annual_deaths_mean = mean(number_of_deaths),
    annual_deaths_min = min(number_of_deaths),
    annual_deaths_max = max(number_of_deaths),
    .groups = "drop"
  )
}

historical_annual_average_hb <-
  past_deaths_hb %>%
  compute_historical_annual_average_deaths(ref_area)

historical_annual_average_la <-
  past_deaths_la %>%
  compute_historical_annual_average_deaths(ref_area)

historical_annual_average_sex_age <-
  past_deaths_sex_age %>%
  compute_historical_annual_average_deaths(sex, age)

historical_annual_average_sex <-
  past_deaths_sex %>%
  compute_historical_annual_average_deaths(sex)

historical_annual_average_age <-
  past_deaths_age %>%
  compute_historical_annual_average_deaths(age)
```


## Check weekly historic averages against NRS computed data

```{r}
weekly_deaths_overall %>%
  filter(sex=="all" & age=="all") %>%
  left_join(historical_average_overall) %>%
  select(year, week_number, place_of_death, deaths_nrs_past_average_all_causes, deaths_mean) %>%
  filter(round(deaths_nrs_past_average_all_causes) != round(deaths_mean)) %>%
  knitr::kable(caption = "Subset of weekly deaths where calculated mean deaths 2015-2019 differed between the COVID-19 related deaths file and the weekly deaths file (i.e. all other entries had the same figures!). Week 53 was computed as the average of deaths in week 53 in 2015 and week 52 in 2016-2019. For all the other datasets the mean deaths computed agree!")
```


# Calculate data averaged over multiple weeks

Once data are broken down by region there are very small figures on a weekly basis, so we can compute a moving average over several weeks instead. This is different to merging figures into 2-week chunks, for example, as information from consecutive weeks will overlap.

The average will be computed to the "left" of the current value (a week's moving average is the average of values at this week + n-1 past weeks, or "right" aligned).

Moving averages for historical data will be computed over the previously computed weekly means & ranges. Computing moving averages over historical ranges produces wider spread data than computing ranges of moving averages (see `order_of_min_max_rolling_mean.R`).


```{r}
weeks_to_average <- 2

## compute moving average over weekly data, using average over k weeks
## using historical data to compute the moving average in the first few weeks of current data
## Note: historical data needs to be the non-summarised (raw) data!
## to compute moving average in first few week(s) of year, we add in the previous years' data and code the weeks so that they retain the right order
## i.e. in 2020 the week_number_run_over starts at 1, and the last week of 2019 is coded as 0, the 2nd last as -1, etc.
## once the moving average has been computed, we remove the past data;
## this approach works for 2021 data seamlessly, using the last weeks of 2020 for the moving average in 2021!
compute_moving_average_for_current_data <- function(current_data, historical_data) {
  bind_rows(
    historical_data %>%  # add historical data and format it so that it matches current data
      filter(year == 2019) %>%  # keep only last year before 2020
      rename(deaths_all_causes = number_of_deaths) %>%  # in historical deaths there is no split between covid/non-covid so we rename to all cause deaths
      mutate(week_number_run_over = -(52-week_number)),
    current_data
  ) %>%
    arrange(week_number_run_over) %>%  # just in case the order got messed up, re-order by week_number_run_over for the computation
    group_by_all() %>% ungroup(matches("^deaths_|week|date|year")) %>%  # clever way of getting grouping by ref_area, sex, age, whatever is available
    mutate(across(
        .cols = matches("^deaths_"), 
        .fns = ~zoo::rollmean(.x, k=weeks_to_average, fill=NA, align="right"), 
        .names = "ma{weeks_to_average}w_{.col}"
        )
    ) %>%
    ungroup %>%
    filter(year > 2019)  # keep only current data
}

rolling_deaths_hb <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_hb, historical_data = past_deaths_hb)

rolling_deaths_la <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_la, historical_data = past_deaths_la)

rolling_deaths_sex_age <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_sex_age, historical_data = past_deaths_sex_age)

rolling_deaths_age <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_age, historical_data = past_deaths_age)

rolling_deaths_sex <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_sex, historical_data = past_deaths_sex)



## inspect the calculations  
rolling_deaths_la %>% filter(week_number_run_over %in% c(1:3,52:54) & str_detect(ref_area,"Glasgow") & place_of_death=="Hospital") %>% select(year, week_number_run_over, ref_area, place_of_death, deaths_all_causes, ma2w_deaths_all_causes) %>% knitr::kable(caption="Showing how rolling average was computed: week 1 is average of week 52 of 2019 (not shown) and week 1 of 2020; week 2 is average of weeks 1 & 2, etc.")

rolling_deaths_sex_age %>% filter(week_number_run_over %in% c(1:3,52:54) & str_detect(sex,"F") & age == "65-74" & place_of_death=="Hospital") %>% select(year, week_number_run_over, sex, age, place_of_death, deaths_all_causes, ma2w_deaths_all_causes) %>% knitr::kable(caption = "Showing how rolling average was computed: week 1 is average of week 52 of 2019 (not shown) and week 1 of 2020; week 2 is average of weeks 1 & 2, etc.")



## helper function that takes historical data and computes a moving average over k weeks
## with the additional trick of using the last week of all the years as the week prior to the first week
## strictly speaking we should be using the last week(s) of 2014 to compute the moving average for the first week(s) in 2015, depending on k; and we shouldn't be using the last week of 2019 in the computation either
## however, the overall effect of this is small since we're averaging over the entire 2015-2019 period
## the inaccuracy of this approach increases with increasing k
## the solution for fixing this is straightforward - just download 2014 data as well, and merge the "current" data and the historical data, and then perform the moving average calculation as usual
compute_moving_average_for_historical_data <- function(historical_data) {
  last_week_in_previous_year_required <- 53 + 2 - weeks_to_average  # this computes the last week needed from the previous year: if averaging over 2 weeks, we need week 3, if over 3 weeks, the lat week needed is 52, etc.
  bind_rows(
    historical_data %>%  # keep last week from all years and convert it to week 0
      filter(week_number %in% last_week_in_previous_year_required:53) %>% 
      mutate(week_number = week_number - 53),  # set week number for data in previous to negative numbers but retaining order 
    historical_data
  ) %>%
  arrange(week_number) %>%  # sort in ascending order of week_number
  group_by_all() %>% ungroup(matches("^deaths_"),week_number) %>%
  mutate(across(
      .cols = matches("^deaths_"), 
      .fns = ~zoo::rollmean(.x, k=weeks_to_average, fill=NA, align="right"), 
      .names = "ma{weeks_to_average}w_{.col}"
      )
  ) %>%
  ungroup %>%
  filter(week_number!=0)
}

historical_average_hb <- compute_moving_average_for_historical_data(historical_average_hb)
historical_average_la <- compute_moving_average_for_historical_data(historical_average_la)
historical_average_sex_age <- compute_moving_average_for_historical_data(historical_average_sex_age)
historical_average_sex <- compute_moving_average_for_historical_data(historical_average_sex)
historical_average_age <- compute_moving_average_for_historical_data(historical_average_age)
```


# Merge weekly COVID/non-COVID-related deaths in 2020/2021 with historic death rates

```{r}
## compute rolling average
merged_deaths_overall <-
  weekly_deaths_overall %>%
  filter(sex=="all" & age=="all") %>%
  inner_join(historical_average_overall %>% mutate(sex = "all", age = "all"),  # only merge for aggregated data b/c that's all we have!
            by = c("place_of_death", "week_number", "sex", "age"))

merged_deaths_hb <-
  rolling_deaths_hb %>%  # use data with rolling movingincluded
  inner_join(historical_average_hb, by = c("week_number","ref_area","place_of_death"))

merged_deaths_la <-
  rolling_deaths_la %>%  # use data with rolling movingincluded
  inner_join(historical_average_la, by = c("week_number","ref_area","place_of_death"))

merged_deaths_sex_age <-
  rolling_deaths_sex_age %>%  # use data with rolling movingincluded
  inner_join(historical_average_sex_age, by = c("place_of_death", "week_number", "sex", "age"))

merged_deaths_sex <-
  rolling_deaths_sex %>%
  inner_join(historical_average_sex, by = c("place_of_death", "week_number", "sex"))

merged_deaths_age <-
  rolling_deaths_age %>%
  inner_join(historical_average_age, by = c("place_of_death", "week_number", "age"))
```


# Summarise annual deaths for 2020 & 2021

For visualising data using maps, we need to compute data for the entire year. Note: the non-covid and covid-related deaths in 2020 don't add up to all cause deaths due to the covid status only starting in week 12!

```{r}
compute_total_deaths_in_year <- function(data_tbl, ...) {
  grouping_vars <- enquos(...)
  data_tbl %>%
    group_by(year, place_of_death, !!!grouping_vars) %>%
    summarise(across(.cols = c(deaths_all_causes, deaths_covid_related, deaths_non_covid), .fns = ~sum(.x,na.rm=TRUE)), .groups = "drop") %>%
    mutate(deaths_all_causes_since_covid = deaths_covid_related + deaths_non_covid)
}

compute_ratio_of_annual_deaths_to_historical <- function(data_tbl) {
  data_tbl %>%
    mutate(
      ratio_annual_deaths_to_historical_mean = deaths_all_causes / annual_deaths_mean,
      ratio_annual_deaths_to_historical_min = deaths_all_causes / annual_deaths_min,
      ratio_annual_deaths_to_historical_max = deaths_all_causes / annual_deaths_max
    )
}

total_deaths_la <-
  merged_deaths_la %>%
  compute_total_deaths_in_year(ref_area) %>%
  left_join(historical_annual_average_la, by = c("place_of_death", "ref_area")) %>%
  compute_ratio_of_annual_deaths_to_historical

total_deaths_hb <-
  merged_deaths_hb %>%
  compute_total_deaths_in_year(ref_area) %>%
  left_join(historical_annual_average_hb, by = c("place_of_death", "ref_area")) %>%
  compute_ratio_of_annual_deaths_to_historical

total_deaths_sex <-
  merged_deaths_sex %>%
  compute_total_deaths_in_year(sex) %>%
  left_join(historical_annual_average_sex, by = c("place_of_death", "sex")) %>%
  compute_ratio_of_annual_deaths_to_historical

total_deaths_age <-
  merged_deaths_age %>%
  compute_total_deaths_in_year(age) %>%
  left_join(historical_annual_average_age, by = c("place_of_death", "age")) %>%
  compute_ratio_of_annual_deaths_to_historical
```


# Visualisations

## Common elements

```{r}
date_range_text <- glue::glue("Data from w/c {format(min(weekly_deaths_overall$date_w_c), '%d %B %Y')} to w/c {format(max(weekly_deaths_overall$date_w_c), '%d %B %Y')} (inclusive).") 

only_2020_text <- glue::glue("Data from 2020 included, starting with w/c {format(min(merged_deaths_age$date_w_c))}.")

source_nrs_text <- "Source: National Records of Scotland"

death_registrations_text <- "Note: all figures are based on date of registration."

vertical_line_text <- "Vertical dotted line at week number 54 represents start of 2021."
```


## Number of deaths by age group

```{r, fig.width=12, fig.height=9, warning=FALSE}
## graph format copied from: https://github.com/davidhen/nrs_covid_stats/
weekly_deaths_overall %>% 
  filter(sex == "all" & place_of_death == "All") %>% 
  filter(age != "all") %>%
  group_by(age) %>% 
  summarise(n = sum(deaths_all_causes)) %>%
  mutate(pct = round(n/sum(n), 3)) %>% 
  ggplot(aes(age, n)) +
  geom_col(fill = "#4477AA") +
  geom_text(aes(label = scales::percent(pct, accuracy = 0.1), y = n + 1000)) +
  theme_minimal() +
  labs(x = "",
       y = "",
       title = "Deaths Associated with COVID-19 by Age Group",
       subtitle = date_range_text,
       caption = paste0(c(date_range_text,source_nrs_text), collapse="\n")
  )
```


## Total deaths in 2020 by age group & place of death

```{r, fig.width=12, fig.height=7, warning=FALSE}
bar_and_error_bars_2020_text <- "Bars are 2020 all-cause deaths, point and bars shows annual mean and range 2015-2019"
excluded_other_place_2020 <- glue::glue("Excluding records with 'Other' place of death, N={total_deaths_age %>% filter(year==2020 & place_of_death=='Other') %>% .$deaths_all_causes %>% sum}")

light_shaded_area_shows_difference <- "Lighter area in the top of bar shows difference between 2020 deaths and historical maximum 2015-2019"

# TODO: make the distinction max vs 2020 figures clearer! maybe annotate?

figure_annual_deaths_by_age_group_2020 <-
  total_deaths_age %>% 
  filter(year==2020) %>%
  filter(place_of_death != "Other") %>%
  ggplot(aes(x = age, y = deaths_all_causes)) +
  # geom_col(fill = "#4477AA", alpha = 0.5, colour = "grey10") +
  geom_col(fill = "grey20", colour = "grey10", alpha = 0.5) +
  geom_col(aes(x=age, y=annual_deaths_max), fill = "#4477AA", colour = "grey10", alpha = 0.5) +  # historical maximum over the actual figure
  geom_point(aes(x=age, y=annual_deaths_mean)) +
  geom_errorbar(aes(x = age, ymin = annual_deaths_min, ymax = annual_deaths_max)) +
  facet_wrap(~place_of_death) +
  scale_y_continuous(labels = function(x) format(x,big.mark=",")) +
  theme_minimal() +
  labs(x = "Age",
       y = "Deaths (N)",
       title = "Deaths in 2020 by age group & place of death",
       subtitle = paste0(c(only_2020_text,light_shaded_area_shows_difference),collapse="\n"),
       caption = paste0(c(excluded_other_place_2020,bar_and_error_bars_2020_text,death_registrations_text,source_nrs_text), collapse="\n")
  )
  
walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_annual_deaths_by_age_group_2020",.x), plot = figure_annual_deaths_by_age_group_2020, width = 12, height = 7, dpi = 300)
)

figure_annual_deaths_by_age_group_2020
```


## Recorded deaths in Scotland, by week number & location

```{r, fig.width=12, fig.height=9, warning=FALSE}
removed_other_category_text <- glue::glue("Excluding 'Other' institutional place of death, N={merged_deaths_overall %>% filter(sex == 'all' & age == 'all' & place_of_death == 'Other') %>% .$deaths_all_causes %>% sum} for weeks 1-{max(merged_deaths_overall %>% filter(year==2020) %>% .$week_number)} in 2020 and 1-{max(merged_deaths_overall %>% filter(year==2021) %>% .$week_number)} in 2021.")

annotations_figure_place_of_death <-
# datapasta::tribble_paste(merged_deaths_overall %>% select(place_of_death))
  tibble::tribble(
    ~place_of_death, ~x, ~y, ~label,
                 "Hospital", 20L, 850, "Shaded area shows range of 2015-2019 deaths; dashed line shows weekly average",
                 "Hospital", 25L, 250, "Hospital deaths dipped below historical minimum and remained low until Winter.",
                "Care home", 35L, 500, "After initial peak, deaths returned to historical range; non-Covid deaths remained low.",
                     "Home & other non-institution", 35L, 500, "The gap between historical high and both types of death at home was high throughout."
                  ) %>% 
  mutate(
    place_of_death = factor(place_of_death, levels = levels(merged_deaths_overall$place_of_death)),  # needs to be factor with same levels, otherwise it messes up level order when added as geom_text later!
    label = str_wrap(label, width = 40)
    )

figure_place_of_death <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(!place_of_death %in% c("All","Other")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  geom_text(data = annotations_figure_place_of_death, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~place_of_death) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_place_of_death",.x), plot = figure_place_of_death, width = 12, height = 9, dpi = 300)
)

figure_place_of_death
```


## Deaths at home, all of Scotland

```{r, fig.width=12, fig.height=9, warning=FALSE}
# TODO: add start of lockdowns 1-3?
# TODO: what is that dip at week 38/39? not obvious - start of september was tier 4 restrictions in big LAs
figure_deaths_at_home <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~place_of_death) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home",.x), plot = figure_deaths_at_home, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home
```


## Deaths at home in 2020, all of Scotland

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_2020 <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  filter(year == 2020) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~place_of_death) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       # subtitle = date_range_text,
       subtitle = "Data from 2020 shown, starting with w/c 30 Dec 2019.",
       caption = paste0(c(death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home_2020",.x), plot = figure_deaths_at_home_2020, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home_2020
```




## Deaths at home, by health board

```{r, fig.width=12, fig.height=9, warning=FALSE}
island_health_boards_merged <- "Note: Orkney, Shetland, & Western health boards were merged into 'Island HBs'; Borders & Dumfries and Galloway health boards were merged into 'B,D&G HB'"
vertical_scale_differs_between_panels_text <- "Note: vertical axis not on the same scale between panels!"

figure_deaths_at_home_by_health_board <-
  merged_deaths_hb %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home_by_health_board",.x), plot = figure_deaths_at_home_by_health_board, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home_by_health_board
```



## Deaths at home with 2-week moving average, by health board

```{r, fig.width=12, fig.height=9, warning=FALSE}
moving_average_text <- "All figures represent deaths averaged over past 2 weeks; this includes historical range and historical mean."

figure_deaths_at_home_2week_average_by_health_board <-
  merged_deaths_hb %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(ma2w_deaths_all_causes, ma2w_deaths_non_covid), 
               names_to = "deaths_type", values_to = "ma2w_deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = ma2w_deaths_min, ymax = ma2w_deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = ma2w_deaths, colour = deaths_type)) +
  geom_line(aes(y = ma2w_deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(moving_average_text, vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home_2week_average_by_health_board",.x), plot = figure_deaths_at_home_2week_average_by_health_board, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home_2week_average_by_health_board
```



## Deaths at home, by local authority

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_by_local_authority <-
  merged_deaths_la %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

# merged_deaths_la %>%
#   filter(place_of_death == "Home & other non-institution") %>%
#   filter(ref_area %in% c("Moray","Highland", "Fife", "Glasgow City")) %>%
#   pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
#                names_to = "deaths_type", values_to = "deaths") %>% 
#   ggplot(aes(x = week_number_run_over)) +
#   geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
#   geom_line(aes(y = deaths, colour = deaths_type)) +
#   geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
#   geom_vline(xintercept = 54, linetype = "dotted") +
#   scale_x_continuous(breaks = seq(0,60,by=10)) +
#   facet_wrap(~ref_area, scales = "free_y", nrow = 2) +
#   theme_minimal() +
#   scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
#                       labels = c("All deaths", 
#                                  "Non Covid-19 deaths"),
#                       guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
#                       ) +
#   theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
#   labs(x = "Week number",
#        y = "Deaths (N)",
#        subtitle = date_range_text,
#        caption = paste0(c(vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
#        colour = "Cause of death"
#        )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home_by_local_authority",.x), plot = figure_deaths_at_home_by_local_authority, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home_by_local_authority
```


## Deaths at home with 2-week moving average, by local authority

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_2week_average_by_local_authority <-
  merged_deaths_la %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(ma2w_deaths_all_causes, ma2w_deaths_non_covid), 
               names_to = "deaths_type", values_to = "ma2w_deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = ma2w_deaths_min, ymax = ma2w_deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = ma2w_deaths, colour = deaths_type)) +
  geom_line(aes(y = ma2w_deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(moving_average_text, vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )
# 
# merged_deaths_la %>%
#   filter(place_of_death == "Home & other non-institution") %>%
#   filter(ref_area %in% c("Moray","Highland", "Fife", "Glasgow City")) %>%
#   pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
#                names_to = "deaths_type", values_to = "deaths") %>% 
#   ggplot(aes(x = week_number_run_over)) +
#   geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
#   geom_line(aes(y = deaths, colour = deaths_type)) +
#   geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
#   geom_vline(xintercept = 54, linetype = "dotted") +
#   scale_x_continuous(breaks = seq(0,60,by=10)) +
#   facet_wrap(~ref_area, scales = "free_y", nrow = 2) +
#   theme_minimal() +
#   scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
#                       labels = c("All deaths", 
#                                  "Non Covid-19 deaths"),
#                       guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
#                       ) +
#   theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
#   labs(x = "Week number",
#        y = "Deaths (N)",
#        subtitle = date_range_text,
#        caption = paste0(c(vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
#        colour = "Cause of death"
#        )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home_2week_average_by_local_authority",.x), plot = figure_deaths_at_home_2week_average_by_local_authority, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home_2week_average_by_local_authority
```


## Deaths at home by age

```{r, fig.width=12, fig.height=9, warning=FALSE}
removed_under_15_text <- glue::glue("Excluding individuals aged <15 at death, total N={merged_deaths_age %>% filter(age %in% c('0','1-14') & place_of_death == 'Home & other non-institution') %>% .$deaths_all_causes %>% sum} for weeks 1-{max(merged_deaths_age %>% filter(year==2020) %>% .$week_number)} in 2020 and 1-{max(merged_deaths_age %>% filter(year==2021) %>% .$week_number)} in 2021.")

figure_deaths_at_home_by_age <-
  merged_deaths_age %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  filter(!age %in% c('0','1-14')) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  # facet_wrap(~age, scales = "free_y") +
  facet_wrap(~age) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text,removed_under_15_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home_by_age",.x), plot = figure_deaths_at_home_by_age, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home_by_age
```


## Deaths at home by sex

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_by_sex <-
  merged_deaths_sex %>%
  mutate(sex = if_else(sex=="F", "Female", "Male")) %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~sex) +
  theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_deaths_at_home_by_sex",.x), plot = figure_deaths_at_home_by_sex, width = 12, height = 9, dpi = 300)
)

figure_deaths_at_home_by_sex
```


## Overall deaths at home 2020 by cause of death

```{r}
# TODO: add yearly range for all deaths
# TODO: split data by covid-underlying cause of desath & covid-factor in death
merged_deaths_overall %>%
  filter(sex=="all", age=="all") %>%
  filter(year==2020) %>%
  filter(place_of_death == "Home & other non-institution") %>%
  group_by(ref_area, year) %>%
  summarise(
    deaths_all_causes = sum(deaths_all_causes, na.rm=TRUE),
    deaths_covid_related = sum(deaths_covid_related, na.rm=TRUE),
    deaths_non_covid = sum(deaths_non_covid, na.rm=TRUE)
  )
```

# Map-based visualisations

## Ratio of 2020 home deaths to historical home deaths by LA

```{r}
areas_relatively_higher_number_home_deaths <- "Lighter areas represent areas with relatively higher number of home deaths in 2020 compared to historical mean"
home_deaths_ratio <- "Ratio computed from total home deaths in 2020 divided by mean annual home deaths 2015-2019"

## max/min used for setting scale of fill colour so it's consistent between plots!
maximum_ratio_between_hb_and_la_home_deaths <-
  bind_rows(
    total_deaths_la,
    total_deaths_hb
  ) %>%
  filter(year==2020 & place_of_death == "Home & other non-institution") %>%
  .$ratio_annual_deaths_to_historical_mean %>%
  max

minimum_ratio_between_hb_and_la_home_deaths <-
  bind_rows(
    total_deaths_la,
    total_deaths_hb
  ) %>%
  filter(year==2020 & place_of_death == "Home & other non-institution") %>%
  .$ratio_annual_deaths_to_historical_mean %>%
  min %>%
  round(digits=1)

# TODO: work out the size of these plots

figure_map_ratio_home_deaths_2020_to_historical_la <-
  total_deaths_la %>%
  filter(
    year == 2020 & place_of_death == "Home & other non-institution"
  ) %>%
  left_join(shapefile_la, by=c("ref_area"="LAD20NM")) %>%
  ggplot(aes(geometry=geometry, fill=ratio_annual_deaths_to_historical_mean), colour="grey10") +
  geom_sf(colour="grey10") +
  scale_fill_viridis_b(limits = c(minimum_ratio_between_hb_and_la_home_deaths, maximum_ratio_between_hb_and_la_home_deaths)) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  labs(x="", y="",
       subtitle = "Ratio of home deaths in 2020 to historical mean 2015-2019, by Local Authority",
       caption = paste0(c(areas_relatively_higher_number_home_deaths, home_deaths_ratio, source_nrs_text), collapse="\n"),
       fill = "Ratio"
       ) +
  NULL


walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_map_ratio_home_deaths_2020_to_historical_la",.x), plot = figure_map_ratio_home_deaths_2020_to_historical_la, width = 12, height = 15, dpi = 300)
)

figure_map_ratio_home_deaths_2020_to_historical_hb <-
  total_deaths_hb %>%
  filter(
    year == 2020 & place_of_death == "Home & other non-institution"
  ) %>%
  left_join(shapefile_hb_uk_wide, by=c("ref_area"="name")) %>%
  ggplot(aes(geometry=geometry, fill=ratio_annual_deaths_to_historical_mean), colour="grey10") +
  geom_sf(colour="grey10") +
  scale_fill_viridis_b(limits = c(minimum_ratio_between_hb_and_la_home_deaths, maximum_ratio_between_hb_and_la_home_deaths)) +
  theme_minimal() +
  theme(axis.text = element_blank(), aspect.ratio = 1.4) +
  labs(x="", y="",
       subtitle = "Ratio of home deaths in 2020 to historical mean 2015-2019, by Health Board",
       caption = paste0(c(areas_relatively_higher_number_home_deaths, home_deaths_ratio, source_nrs_text), collapse="\n"),
       fill = "Ratio"
       ) +
  NULL


walk(
  .x = c(".pdf",".svg",".png"),
  .f = ~ggsave(filename = paste0("./outputs/figure_map_ratio_home_deaths_2020_to_historical_hb",.x), plot = figure_map_ratio_home_deaths_2020_to_historical_hb, width = 12, height = 15, dpi = 300)
)

```

