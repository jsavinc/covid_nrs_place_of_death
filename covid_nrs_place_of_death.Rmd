---
title: "Place of death in NRS COVID-19 deaths"
author: "Jan Savinc"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load packages

```{r, warning=FALSE, message=FALSE}
## install packages from github if not yet available!
# remotes::install_github("datasciencescotland/opendatascot", force = TRUE)
# remotes::install_github("Health-SocialCare-Scotland/phsmethods", force = TRUE)

library(tidyverse)  # for tidy workflow
library(opendatascot)  # importing data from ScotGov open data website
library(phsmethods)  # methods for working with PHS data
library(readxl)  # for reading excel files
# library(SPARQL)  # taken care of by opendatascot
library(lubridate)  # dealing with dates
library(janitor)  # for cleaning column names
library(ISOweek)  # for computing date from ISO week number + year
library(sf)  # for mapping
library(ggrepel)  # for 'mapping'repelling' labels/texst in ggplot
library(patchwork)  # for assembling plots
library(extrafont)  # for working with fonts
library(openxlsx)  # for creating xlsx files
```


# Set up SPARQL query

Note: not needed if using `opendatascot`
To access the latest NRS data using their API, we first setup a SPARQL query.

```{r}
# endpoint <- "http://statistics.gov.scot/sparql.json"
endpoint <- "http://statistics.gov.scot/sparql"
```


# Copyright attribution

All data used for this study were obtained from the National Records Scotland (NRS) and are Â© Crown copyright, 2020; the details of the licence can be viewed on the [Open Government Licence website](http://www.nationalarchives.gov.uk/doc/open-government-licence/open-government-licence.htm)


# Dates represent event registration, not occurrence!

From NRS website:

> All routine vital events information we publish is based on the date of registration, not the date on which the event occurred. Inevitably, of course, there are delays between the occurrence of an event and its registration.


# Context of lockdowns

A recent timeline of COVID-19 events in Scotland is [available here](https://spice-spotlight.scot/2021/01/29/timeline-of-coronavirus-covid-19-in-scotland/). Including these might help in the interpreration fo the figures, though the figures are already pretty busy. This is a potential future TODO!


# Load info about latest data

A separate script checks for updated data and downloads it, also updating these files with the locations of the downloaded data:

```{r}
file_data_sources <- "./table_of_data_sources.csv"
file_historical_data_sources <- "./table_of_historical_data_sources.csv"
file_case_trends_data_sources <- "./table_of_case_trends_data_sources.csv"

table_of_data_sources <- read_csv(file = file_data_sources)
table_of_historical_data_sources <- read_csv(file = file_historical_data_sources)
table_of_case_trends_data_sources <- read_csv(file = file_case_trends_data_sources)

table_of_data_sources %>%
  knitr::kable(caption = "Latest data used in this report.")
```


## Set up output directory

Because data are updated on a weekly basis, we'll have a separate directory for every week the data are updated:

```{r}
latest_data_date <- strftime(max(table_of_data_sources$last_modified), format="%F")

dir_outputs <- paste0("./outputs/",latest_data_date)
if (!dir.exists(dir_outputs)) dir.create(dir_outputs)
```


# Import & wrangle data

We're importing two kinds of data:

1. Weekly deaths involving COVID-19 from Scottish gov't open data service, broken down by week & place of death (home or institution)
2. Historical deaths 2015-2019, grouped by week & place of death

For both of these, we'll also look at crosstabulated figures for:

* Health board
* Local Authority
* Sex
* Age
* ~~Ethnicity~~ *Note: not sure this is available*

There are two ways of obtaining the data:

1. ~~Using their SPARQL-based API ("data cube"), which can be accessed using the `opendatascot` package in R; the data can be seen on [the Scottish Gov't open data website](https://statistics.gov.scot/data/deaths-involving-coronavirus-covid-19)~~
    - Update: it's difficult to keep track of data updates using the API - it's simpler to query the .xlsx/.csv files (next bullet point) for when they were last modified and download the weekly update once it's been released!
2. There are a number of datasets, including the demographic/geographic crosstabulations available on the "Related Statistics" section of the [deaths involving COVID-19 website]( https://www.nrscotland.gov.uk/statistics-and-data/statistics/statistics-by-theme/vital-events/general-publications/weekly-and-monthly-data-on-births-and-deaths/deaths-involving-coronavirus-covid-19-in-scotland), under the *Ad-hoc queries section*. They are updated weekly, and also contain historical figures.

Note that the [*About* tab of the "data cube" interface](https://statistics.gov.scot/resource?uri=http%3A%2F%2Fstatistics.gov.scot%2Fdata%2Fdeaths-involving-coronavirus-covid-19) says the following about Health Board & Local Authority figures:

>Health Board and Local Authority figures include non-residents. Deaths are allocated to areas based on the usual residence of the deceased. If the deceased was not a Scottish resident, the death is allocated to the area where the death occurred.

This means we'll need to download those figures from the website rather than using the API!

Note that the weekly deaths due to COVID-19 in 2020 & 2021 also include a weekly average 2015-2019, but for the purposes of showing the range of deaths (weekly minima & maxima), we need the weekly figures for individual years & the appropriate cross-tabulations.

```{r}
# TODO: remove this section, params not used anymore
# # "unpack" the data source tables
# table_of_data_sources <- params$data_sources
# table_of_historical_data_sources <- params$historical_data_sources
# table_of_case_trends_data_sources <- params$case_trends_data_sources
```


## Parsing week numbers

In the `opendatascot`-imported data, `refPeriod` refers to the week number (called `week of occurrence` in the `.xlsx`/`.csv`-imported data has), as defined by [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date), and can be computed from a date with `lubridate::isoweek()`; the first week of 2020 is the week starting with Monday 2019-12-30, ~~and the corresponding start dates for each week can be computed by adding weeks using `lubridate::dweeks()` to that date.~~ This is non-trivial, because the number of iso weeks in a year isn't constant. The `ISOweek::ISOweek2date()` function deals with this issue in a crude manner, and allows us to compute the date (w/c on date) from the year & week number. It relies on being provided a valid week number (some years have 52 and some have 53), but it's probably safe to assume that the NRS data has valid dates.

Invalid week numbers will produce a date in the next year: e.g. week 53 in 2021 would actually start in 2022, which makes it invalid. We can test for that by checking that the year provided is the same year in the date produced.

We'll also compute a 'run-over' week number of 2021 in case we plot both years on a contibuous X-axis - in this case, week 1 of 2021 follows week 53 of 2020, so we start counting from 54 in 2021.

```{r}
date_first_week_2020 <- ymd("2019-12-30")
ISOweek::ISOweek2date(weekdate = "2019-W53-1")
ISOweek::ISOweek2date(weekdate = "2020-W01-1")
ISOweek::ISOweek2date(weekdate = "2020-W52-1")
ISOweek::ISOweek2date(weekdate = "2020-W53-1")
ISOweek::ISOweek2date(weekdate = "2021-W01-1")
ISOweek::ISOweek2date(weekdate = "2021-W53-1")

compute_start_date_from_week_number <- function(week_number, year_number) {
  ## this assumes a valid week number! There are 52 or 53 weeks in a year
  isoweek_string <- glue::glue("{year_number}-W{str_pad(week_number, width=2, pad='0')}-1")
  # computed_dates <- ISOweek::ISOweek2date(isoweek_string)
  computed_dates <- rep(NA_Date_,times = length(week_number))
  computed_dates[which(!is.na(week_number))] <- ISOweek::ISOweek2date(isoweek_string[which(!is.na(week_number))])  # return NA instead of failing with ISOweek!
  ## invalid weeks will result in a computed date in a year after the requested year...
  ## a valid week can result in a date that starts in the year before!
  if (any(year_number<year(ymd(computed_dates)), na.rm = TRUE)) stop("invalid week number provided!")
  return(computed_dates)
}

tibble(
    week_number = c(1,2,3,52,53)
  ) %>%
  mutate(
    date = compute_start_date_from_week_number(week_number = week_number, year_number = 2020),
    iso_week_from_date = isoweek(date)
  ) %>% knitr::kable(caption = "Examples of computing start date for each week, and computing isoweek from the dates!")
```


## Consistent Place of death coding

Place of death was named differently between datasets (location/place) and the different places were also named slightly differently, so we find all of them and recode them to the same:

```{r}
order_of_place_of_death_levels <- c("Hospital", "Care home", "Home & other non-institution", "Other", "All")

recode_place_of_death <- function(data_tbl) {
  data_tbl %>%
    mutate(place_of_death = case_when(
      str_detect(place_of_death, pattern = regex(pattern = "all", ignore_case = TRUE)) ~ "All",
      str_detect(place_of_death, pattern = regex(pattern = "care.*home", ignore_case = TRUE)) ~ "Care home",
      str_detect(place_of_death, pattern = regex(pattern = "(non.*institut)|home", ignore_case = TRUE)) ~ "Home & other non-institution",
      str_detect(place_of_death, pattern = regex(pattern = "hospital", ignore_case = TRUE)) ~ "Hospital",
      str_detect(place_of_death, pattern = regex(pattern = "other", ignore_case = TRUE)) ~ "Other",
      TRUE ~ NA_character_
      ) %>%
        factor(x = ., levels = order_of_place_of_death_levels)
    )
}
```


## Consistent Cause of death coding

The `opendatascot`-imported data distinguishes "all causes" deaths from "covid-related" deaths - the non-covid-related deaths are the difference between those. In contrast, the other weekly datasets code cause of death as either covid-related or non-covid-related, in which case we need to compute all cause deaths as the sum of the two.

We'll change the wording of these to a consistent format so it's easier to compute consistent columns. The below function will also compute non-covid deaths for data where all deaths and covid deaths are provided, and all deaths where covid- and non-covid-related deaths are provided.

This involves pivotting the number of deaths variable into wide format based on the cause of death. Because of this, we need to deal with implicit missing values:

The first COVID-19-related deaths were reported from week 12 onwards. In some of the datasets, a missing/omitted value represents 0 cases in that category, when a 0 should have been recorded. E.g. deaths in "Other institutions" are very low, and if a record is missing for that category, we should assume 0 deaths.

On 3 Februrary 2021 as I was updating the script, the weekly figures started distinguishing cause of death: COVID-19 can be a contributory factor, or an underlying cause of death. For the purposes of this study, COVID-19 deaths are in the minority, and we will disregard this distinction for now.


```{r}
## helper function to make consistently coded cause of death
recode_cause_of_death <- function(data_tbl) {
  data_tbl %>%
    mutate(
      cause_of_death = case_when(
        cause_of_death == "all-causes" ~ "deaths_all_causes",
        cause_of_death == "all-causes-average-of-corresponding-week-over-previous-5-years" ~ "deaths_nrs_past_average_all_causes",
        cause_of_death == "covid-19-related" ~ "deaths_covid_related",
        cause_of_death == "COVID-19 mentioned" ~ "deaths_covid_related",
        cause_of_death == "COVID-19 contributory factor" ~ "deaths_covid_related",
        cause_of_death == "COVID-19 underlying cause" ~ "deaths_covid_related",
        cause_of_death == "Non-COVID-19" ~ "deaths_non_covid",
        TRUE ~ NA_character_
      )
    )
}

# TODO:  still too complicated to safely use as a function...
## find which combinations of geographic area, cause of death, and place of death are missing and set the number of deaths to 0 for them
# complete_weekly_deaths_with_implicit_zeros <- function(data_tbl) {
#   data_tbl %>%
#   tidyr::complete(
#       nesting(year, week_number, week_number_run_over, date_w_c),  # these are 'identifying' variables that shouldn't be combinatorily exploded
#       ref_area, cause_of_death, place_of_death,  # these are the variables we want to have all combinations of, and missing combinations are set to 0 deaths
#       fill = list(number_of_deaths = 0)
#       )
# }

## calculate number of deaths after recoding cause of death -
## recoding results in two entries for covid-related deaths, so we need to sum over them
## this is achieved by grouping over all variables other than number of deaths
recalculate_number_of_deaths_after_recoding_cause_of_death <- function(data_tbl) {
  data_tbl %>%
  group_by_all %>% 
  ungroup(number_of_deaths) %>%  # this is done by grouping over everything except the number of deaths
  summarise(number_of_deaths = sum(number_of_deaths), .groups = "drop")  # recompute the sum of deaths
}

## covid death reporting started in week 12, 2020 - before then it doesn't make sense to distunguish between covid and non-covid deaths, and only the all cause death figure should be kept
## by using the 'overrun' weeks we ensure that 2021 or later isn't affected
## note: we're keeping all cause deaths!
set_covid_and_non_covid_deaths_to_zero_before_reporting_started <- function(data_tbl) {
  data_tbl %>%
    mutate(
      deaths_non_covid = if_else(
        condition = week_number_run_over < 12,
        true = NA_real_,
        false = deaths_non_covid
      ),
      deaths_covid_related = if_else(
        condition = week_number_run_over < 12,
        true = NA_real_,
        false = deaths_covid_related
      )
    )
}

# TODO: delete below function, it's too complicated and I've broken it down to the individual functions
# recode_cause_of_death_and_compute_columns <- function(data_tbl) {
#   potential_grouping_variables <- c("ref_area","sex","age","ref_period")
#   grouping_variables <- potential_grouping_variables[which(potential_grouping_variables %in% names(data_tbl))]
#   
#   interim_data_tbl <- 
#     data_tbl %>%
#     recode_cause_of_death() %>%
#     tidyr::complete(
#       nesting(year, week_number, week_number_run_over, date_w_c),
#       !!!rlang::syms(grouping_variables),
#       cause_of_death, place_of_death,
#       fill = list(number_of_deaths = 0)
#       ) %>%
#     pivot_wider(names_from = "cause_of_death", values_from = "number_of_deaths")
#   
#   ## compute non-covid deaths from all deaths minus covid deaths
#   if (!"deaths_non_covid" %in% names(interim_data_tbl)) {
#     interim_data_tbl <-
#       interim_data_tbl %>%
#       mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related)
#   }
#   ## compute all deaths from non-covid deaths + covid deaths
#   if (!"deaths_all_causes" %in% names(interim_data_tbl)) {
#     interim_data_tbl <-
#       interim_data_tbl %>%
#       mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related)
#   }
#   
#   interim_data_tbl <-
#     interim_data_tbl %>%  # set as missing covid- & non-covid-related deaths before week 12
#     mutate(
#       deaths_non_covid = if_else(
#         condition = week_number_run_over < 12,
#         true = NA_real_,
#         false = deaths_non_covid
#       ),
#       deaths_covid_related = if_else(
#         condition = week_number_run_over < 12,
#         true = NA_real_,
#         false = deaths_covid_related
#       )
#     )
#   
#   return(interim_data_tbl)
# }
```


## Consistent use of missing value

```{r}
replace_na_with_0_from_week_12 <- function(data_tbl) {
  data_tbl %>%
    mutate(
      value = if_else(
        condition = week_number_roll_over >=12 & is.na(number_of_deaths),
        true = 0,
        false = number_of_deaths
      )
    )
}
```


## Merging health boards

Smaller health boards were merged... TODO!

> "Note: Orkney, Shetland, & Western health boards were merged into 'Island HBs'; Borders & Dumfries and Galloway health boards were merged into 'B,D&G HB'"


## Load weekly COVID-19 related deaths

~~Using `opendatascot` to load weekly deaths the level of geography can be specified, so we can have more or less granular data~~ Choosing a more granular level than Scotland-wide data means place of death is collapsed to the 'all' category only, see note above! Even for the Scotland-wide data, place of death is collapsed to 'All' for the granular sex & age categories, actually.

I've also attempted loading the case counts using `ckanr` using the CKAN API from the opendata.nhs.scot website, but gave that up in favour of using their `.csv` links instead to download daily-updated data.

Note about weekly LA/HB data:

> From 14/12/2020 confirmed positive cases are now allocated to an area based on the postcode recorded in the testing system. Previously cases were allocated to local areas mainly based on their usual residential address recorded in the Community Health Index (CHI) database. This change will impact on newly reported cases on this day.

> Please note that the updated methodology for determining COVID-19 related ICU admissions has been applied to the historic data. The updated definition is as follows: A patient who has tested positive for COVID at any time in the 21 days prior to admission to ICU, or who have tested positive from the date of admission up to and including the date of ICU discharge.

> In addition, on 30th October it came to our attention that there is an ongoing issue when linking ICU data to the lab data for COVID-19 test results. Any COVID-19 positive patients with a missing CHI that had a first positive test in the community are unable to be linked to the ICU data. As a result the COVID-19 positive numbers could be underreported by a small number.


`crude_rate_positive`: Crude rate of total positive cases (cumulative) per 100,000 population.

```{r}
download_dir <- "./downloaded_data"
if (!dir.exists(download_dir)) dir.create(download_dir)  # create download dir if it doesn't exist

files_weekly_deaths <- set_names(x = as.list(table_of_data_sources$path_latest), nm = table_of_data_sources$short_name)

# checking out structure

# ods_all_datasets() %>% View()
# ods_structure("deaths")  # can we import all deaths-related data this way?
# ods_structure("coronavirus-covid-19-management-information")

# ods_dataset("coronavirus-covid-19-management-information", geography = "hb") %>%
#   filter(variable == "testing-new-cases-reported")
# 
# ods_dataset("coronavirus-covid-19-management-information", geography = "hb", variable = "testing-new-cases-reported")
# ods_dataset("coronavirus-covid-19-management-information", geography = "la", variable = "testing-new-cases-reported")
# ods_dataset("coronavirus-covid-19-management-information", variable = "testing-new-cases-reported")
# 
# ods_print_query(dataset = "coronavirus-covid-19-management-information", geography = "hb", variable = "testing-new-cases-reported") %>% dput
# ods_print_query(dataset = "coronavirus-covid-19-management-information", variable = "testing-new-cases-reported") %>% dput
#   
# modified_query <- "PREFIX qb: <http://purl.org/linked-data/cube#>                 PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>                 PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> select   ?refArea ?refPeriod ?measureType ?variable ?value where { ?data qb:dataSet <http://statistics.gov.scot/data/coronavirus-covid-19-management-information>. ?data <http://purl.org/linked-data/sdmx/2009/dimension#refArea> ?refArea. ?data <http://purl.org/linked-data/sdmx/2009/dimension#refPeriod> ?refPeriod. ?data <http://purl.org/linked-data/cube#measureType> ?measureType. ?data <http://statistics.gov.scot/def/dimension/variable> ?variable. ?data ?measureType ?value.  filter (regex(str(?variable ), 'testing-new-cases-reported'))  } order by ?refPeriod ?refArea"
# 
# modified_query %>%
#   opendatascot:::ods_query_database(endpoint, query = .) %>%
#   opendatascot:::pre_process_data()
# 
# query <- ""

# 
# library(ckanr)
# ckanr_setup(url = "https://www.opendata.nhs.scot/")
# # package_list(as = "table")
# # tag_list(as = "table")
# package_search(q = 'daily', rows = 2, as = 'table') %>% str
# 
# 
# download_data_from_opendata_via_ckan_api <- function(resource_id) {
#   ckan <- ckanr::src_ckan("https://www.opendata.nhs.scot/")
#   dplyr::tbl(src = ckan$con, from = resource_id_daily_case_trends_la, ) %>% 
#   as_tibble()
# }
# 
# resource_id_daily_case_trends_la <- "427f9a25-db22-4014-a3bc-893b68243055"
# 
# resource_show(id = resource_id_daily_case_trends_la, as = "table")

# ods_print_query("deaths")

# ods_structure("deaths-involving-coronavirus-covid-19")
# ods_schemes("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19")
# ods_print_query("deaths-involving-coronavirus-covid-19", geography = "la")
# ods_find_lower_geographies("S92000003")  # Scotland's refArea = S92000003
# phsmethods::match_area("S92000003")  # "Scotland"

## helper function that links the 9-character geography code to its name
make_human_readable_ref_area <- function(data_tbl, ref_area = refArea) {
  enquoted_ref_area <- enquo(ref_area)
  data_tbl %>%
    mutate(
      !!enquoted_ref_area := phsmethods::match_area(!!enquoted_ref_area)
    )
}

# raw_covid_deaths <- list(
#   scotland = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc"),
#   health_board = ods_dataset("deaths-involving-coronavirus-covid-19", geography = "hb"),
#   local_authority = ods_dataset("deaths-involving-coronavirus-covid-19",geography = "la")
# ) %>%
#   map(.x = ., .f = ~make_human_readable_ref_area(data_tbl = .x))

weekly_deaths_overall <-
  ods_dataset("deaths-involving-coronavirus-covid-19", geography = "sc") %>%
  make_human_readable_ref_area %>%
  clean_names() %>%
  ## below series of rename operations are a stupid way of dealing with the possibility of different variable name conventions in the ods_dataset data: sometimes they are in snake_case, and sometimes in camelCase, seemingly unpredictably
  rename_at(.vars = vars(matches("location", ignore.case = TRUE)), ~"place_of_death") %>%
  rename_at(.vars = vars(matches("period", ignore.case = TRUE)), ~"ref_period") %>%
  rename_at(.vars = vars(matches("area", ignore.case = TRUE)), ~"ref_area") %>%
  rename_at(.vars = vars(matches("measure", ignore.case = TRUE)), ~"measure_type") %>%
  rename_at(.vars = vars(matches("cause", ignore.case = TRUE)), ~"cause_of_death") %>%
  rename_at(.vars = vars(matches("sex", ignore.case = TRUE)), ~"sex") %>%
  rename_at(.vars = vars(matches("age", ignore.case = TRUE)), ~"age") %>%
  rename_at(.vars = vars(matches("value", ignore.case = TRUE)), ~"number_of_deaths") %>%  # rename so it's consistent with other data
  filter(!ref_period %in% as.character(2020:2021)) %>% # remove totals for 2020 & 2021, we only want the weekly figures
  mutate(
    year = parse_integer(str_extract(ref_period, pattern="^(2020|2021)")),
    week_number = parse_integer(str_remove(ref_period, pattern = "^(2020|2021)\\-")),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    number_of_deaths = as.numeric(number_of_deaths),  # convert to numeric!
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  select(-c(measure_type)) %>%  #  measure_type is count for all data
  recode_place_of_death() %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # not needed here probably, but no harm in including it
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%  # this dataset is well-formatted and has no implicit missing values!
  mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related)  # compute non-covid deaths from the other two figures - will be NA where either is missing
  

# weekly_deaths_sex_age_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-age-sex.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)


weekly_deaths_sex_age <-  # structure here is a bit more complicated - headers in row 3, but sex & age headers in row 4
  readxl::read_excel(files_weekly_deaths$sex_age, sheet = 2, skip = 4, col_names = c("week_number","place_of_death","sex","age","cause_of_death","number_of_deaths"), guess_max = 1e5) %>%
  drop_na(number_of_deaths) %>%    # remove empty rows & one row where it's just the copyright notice
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # recompute the sum of deaths
  tidyr::complete(  # complete implicit missing entries and make them 0
    nesting(week_number,week_number_run_over,date_w_c,year),
    age,sex,place_of_death,cause_of_death,
    fill = list(number_of_deaths = 0)
  ) %>%
  recode_place_of_death() %>%  # this needs to be done after recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%   # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()

# 
# weekly_deaths_la_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-council-area-location.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)

weekly_deaths_la <- 
  read_excel(files_weekly_deaths$la, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = council, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # recompute the sum of deaths
  tidyr::complete(
      nesting(year, week_number, week_number_run_over, date_w_c),  # these are 'identifying' variables that shouldn't be combinatorily exploded
      ref_area, cause_of_death, place_of_death,  # these are the variables we want to have all combinations of, and missing combinations are set to 0 deaths
      fill = list(number_of_deaths = 0)
      ) %>%
  # complete_weekly_deaths_with_implicit_zeros() %>%
  recode_place_of_death() %>%  # this needs to be done before recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%   # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()


# weekly_deaths_hb_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)

weekly_deaths_hb <- 
  read_excel(files_weekly_deaths$hb, sheet = 2, skip = 2) %>% 
  clean_names %>%
  rename(week_number = week_of_occurrence, ref_area = health_board, place_of_death = location_of_death, number_of_deaths = deaths) %>%
  filter(!is.na(number_of_deaths)) %>%  # remove blank rows & copyright entry
  mutate(
    year = 2000L + parse_integer(str_sub(week_number, 1, 2)),
    week_number = parse_integer(str_sub(week_number, 4, 5)),
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)  # invent a "run-over" week number - weeks 54+ are in 2021
  ) %>%
  recode_cause_of_death() %>%
  recalculate_number_of_deaths_after_recoding_cause_of_death %>%  # recompute the sum of deaths
  tidyr::complete(
      nesting(year, week_number, week_number_run_over, date_w_c),  # these are 'identifying' variables that shouldn't be combinatorily exploded
      ref_area, cause_of_death, place_of_death,  # these are the variables we want to have all combinations of, and missing combinations are set to 0 deaths
      fill = list(number_of_deaths = 0)
      ) %>%
  # complete_weekly_deaths_with_implicit_zeros() %>%
  recode_place_of_death() %>%  # this needs to be done before recoding cause of death, otherwise we also include the "all" figure which isn't included in this dataset
  pivot_wider(names_from = cause_of_death, values_from = number_of_deaths) %>%  # make separate columns for causes of death figures
  mutate(deaths_all_causes = deaths_non_covid + deaths_covid_related) %>%  # compute all cause deaths from the other two figures reported
  set_covid_and_non_covid_deaths_to_zero_before_reporting_started()

## compute weekly data for sex and age separately
## sum over sex or age, respectively
weekly_deaths_sex <-
  weekly_deaths_sex_age %>%
  filter(age!="all") %>%
  group_by(week_number, week_number_run_over, year, date_w_c, sex, place_of_death) %>%
  summarise(across(starts_with("deaths_"), ~sum(.x)), .groups = "drop")

weekly_deaths_age <-
  weekly_deaths_sex_age %>%
  filter(sex!="all") %>%
  group_by(week_number, week_number_run_over, year, date_w_c, age, place_of_death) %>%
  summarise(across(starts_with("deaths_"), ~sum(.x)), .groups = "drop")
```


### Checking week number coding

```{r}
weekly_deaths_sex_age %>% 
  count(year, date_w_c, week_number, week_number_run_over) %>% 
  slice(1:3, (nrow(.) - 3):nrow(.)) %>% 
  select(-n) %>% 
  knitr::kable(caption = "Checking the computation of dates from week numbers - note how the 1st week of 2020 started in 2019.")
```


## Load historical deaths data

The format of the .xlsx files is that sheet 1 is a table of contents, sheet 2 contains the data, and sheet 3 is a pivot table for subsetting data.

```{r, warning=FALSE}
files_historical_deaths <- set_names(x = as.list(table_of_historical_data_sources$path_latest), nm = table_of_historical_data_sources$short_name)


## overall file - where did I get the link from? it's not obviously available from the website...
# past_deaths_overall_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files/statistics/covid19/weekly-deaths-by-location-2015-2019.csv",
#                 destfile = tempfile(),
#                 quiet = FALSE)
# 
# past_deaths_hb_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-date-health-board-location-15-19.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)
# 
# past_deaths_la_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-council-areas.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)
# 
# past_deaths_sex_age_file <-
#   curl_download(url = "https://www.nrscotland.gov.uk/files//statistics/covid19/weekly-deaths-by-location-age-group-sex-15-19.xlsx",
#                 destfile = tempfile(),
#                 quiet = FALSE)

past_deaths_overall <- 
  read_csv(files_historical_deaths$overall, skip = 2) %>%
  rename(year = 1) %>%  # rename first column
  mutate(
    place_of_death = if_else(is.na(`1`), true = year, NA_character_)
  ) %>%
  fill(place_of_death, .direction="down") %>%  # LOCF on place_of_death
  drop_na(`1`) %>%
  pivot_longer(cols = all_of(as.character(1:53)), values_to = "number_of_deaths", names_to = "week_number") %>%
  mutate(week_number=as.integer(week_number)) %>%
  recode_place_of_death()

past_deaths_hb <- 
  readxl::read_excel(files_historical_deaths$hb, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  drop_na(number_of_deaths) %>%  # remove empty rows & one row where it's just the copyright notice
  rename(  # same format as current data
    week_number = matches("week"),
    place_of_death = matches("location"),
    ref_area = health_board
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  tidyr::complete(
    nesting(week_number,year),  # unique combinations that we don't want to combinatorily explode
    ref_area, place_of_death,  # fill in missing combinations of hb & pod with 0 deaths
    fill = list(number_of_deaths = 0)
  ) %>% 
  recode_place_of_death()  # recode place of death after completing missing combinations, otherwise the factor level "All" gets exploded also

past_deaths_la <-
  readxl::read_excel(files_historical_deaths$la, sheet = 2, skip = 2, col_names = TRUE) %>%  # first two rows are empty, row 3 has headers
  clean_names() %>%
  drop_na(number_of_deaths) %>%  # remove empty rows & one row where it's just the copyright notice
  rename(  # same format as current data
    week_number = matches("week"),
    place_of_death = matches("location"),
    ref_area = council_area
  ) %>%
  mutate(
    week_number = as.integer(week_number)
  ) %>%
  tidyr::complete(
    nesting(week_number,year),  # unique combinations that we don't want to combinatorily explode
    ref_area, place_of_death,  # fill in missing combinations of la & pod with 0 deaths
    fill = list(number_of_deaths = 0)
  ) %>% 
  recode_place_of_death()  # recode place of death after completing missing combinations, otherwise the factor level "All" gets exploded also

past_deaths_sex_age <-  # structure here is a bit more complicated - headers in row 3, but sex & age headers in row 4
  readxl::read_excel(files_historical_deaths$sex_age, sheet = 2, skip = 4, col_names = c("year","week_number","place_of_death","sex","age","number_of_deaths"), guess_max = 1e5) %>%
  drop_na(number_of_deaths) %>%    # remove empty rows & one row where it's just the copyright notice
  mutate(
    year = 2000L + as.integer(year),
    week_number = as.integer(week_number)
  ) %>%
  tidyr::complete(
    nesting(week_number,year),  # unique combinations that we don't want to combinatorily explode
    sex, age, place_of_death,  # fill in missing combinations of age, sex, pod, with 0 deaths
    fill = list(number_of_deaths = 0)
  ) %>% 
  recode_place_of_death()

## compute weekly data for sex and age separately
## sum over sex or age, respectively
past_deaths_sex <-
  past_deaths_sex_age %>%
  group_by_all %>%
  ungroup(age, number_of_deaths) %>%  # this is done by grouping over everything except the number of deaths & sex
  summarise(number_of_deaths = sum(number_of_deaths), .groups = "drop")

past_deaths_age <-
  past_deaths_sex_age %>%
  group_by_all %>%
  ungroup(sex, number_of_deaths) %>%  # this is done by grouping over everything except the number of deaths & sex
  summarise(number_of_deaths = sum(number_of_deaths), .groups = "drop")
```


### Do we get the same number of deaths between datasets?

```{r}
## check that the results are the same as overall deaths
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_hb, past_deaths_hb, past_deaths_sex_age),
  .y = c("overall","health_board","council_area","sex_age"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(!is.na(year) & place_of_death!="All") %>%  # to remove summary values from the data
      group_by(dataset,year) %>%
        summarise(total = sum(number_of_deaths), .groups = "drop")
  }
) %>% 
  pivot_wider(names_from=year,values_from=total) %>%
  knitr::kable(caption = "Number of historical deaths by year as calculated from different datasets. The overall dataset and age/sex breakdown agree in figures, and the HB and LA breakdowns agree, but the two pairs differ from each other. The difference is in both directions, some years there are more deaths recorded in one pair, and some years in the other. This may be due to the following (verbatim from data description online): Health Board and Local Authority figures include non-residents. Deaths are allocated to areas based on the usual residence of the deceased. If the deceased was not a Scottish resident, the death is allocated to the area where the death occurred.")
```


## Load map data with `sf`

I previously downloaded shapefiles for:

* Local Authority Districts (LAD) for 2020 (BUC-level resolution): https://geoportal.statistics.gov.uk/datasets/local-authority-districts-may-2020-boundaries-uk-buc
* Health Boards https://data.gov.uk/dataset/27d0fe5f-79bb-4116-aec9-a8e565ff756a/nhs-health-boards
  - Note: this is a fairly high resolution, don't need this much detail!
  - I found a discussion of this on [a github covid-related project](https://github.com/tomwhite/covid-19-uk-data/issues/18#issuecomment-622353841), and user **robchallen** produced a zip file containing [UK-wide health board boundaries](https://github.com/tomwhite/covid-19-uk-data/files/4563933/UK_covid_reporting_regions.zip)


```{r}
# shapefile_hb <- st_read(dsn = "./map_data/hb")  # too detailed!
shapefile_hb_uk_wide <- st_read(dsn = "./map_data/hb_uk_wide/UK_covid_reporting_regions")
shapefile_la <- st_read(dsn = "./map_data/la")

# merged_deaths_la %>%
#   filter(week_number==53 & place_of_death=="Home & other non-institution") %>%
#   left_join(shapefile_la,by=c("ref_area"="lad19nm")) %>%
#   ggplot(aes(fill = deaths_all_causes, geometry = geometry, group=ref_area)) +
#   geom_sf()
# 
# merged_deaths_hb %>%
#   filter(week_number==53 & place_of_death=="Home & other non-institution") %>%
#   left_join(shapefile_hb_uk_wide,by=c("ref_area"="name")) %>%
#   ggplot(aes(fill = deaths_all_causes, geometry = geometry)) +
#   geom_sf() +
#   theme(aspect.ratio = 1.3)

# ggplot(data = shapefile_hb_uk_wide, aes(geometry=geometry)) + geom_sf()
  
## simple UK map
# ggplot(data = map_data(map = "world", region = "UK"), aes(x=long, y = lat, group = group)) +
#   geom_polygon() +
#   coord_map()
```


## Load COVID case counts by LA/HB

```{r}
files_case_counts <- set_names(x = as.list(table_of_case_trends_data_sources$path_latest), nm = table_of_case_trends_data_sources$short_name)

cases_hb <- read_csv(
  files_case_counts$hb, 
  col_types = 
    cols(
    .default = col_double(),
    `_id` = col_skip(),
    DailyDeaths = col_skip(),  # not needed, we get this elsewhere!
    Date = col_date(format = "%Y%m%d"),
    HB = col_character(),
    HBName = col_character(),
    HospitalAdmissionsQF = col_character(),
    ICUAdmissionsQF = col_character()
    ),
  ) %>% clean_names() %>%
  rename(ref_area = hb_name) %>%
  mutate(
    year = parse_integer(str_sub(ISOweek(date), start = 1, end = 4)),  # parse ISO year, otherwise the first few days of 2021 will belong to 2021 erroneously!
    week_number = parse_integer(str_sub(ISOweek(date), start = 7, end = 8)),
    ref_area = phsmethods::match_area(hb)  # convert to standard HB names
    )

cases_la <- read_csv(
  file = files_case_counts$la, 
  col_types = 
    cols(
    .default = col_double(),
    `_id` = col_skip(),
    DailyDeaths = col_skip(),  # not needed, we get this elsewhere!
    Date = col_date(format = "%Y%m%d"),
    CA = col_character(),
    CAName = col_character()
  )
) %>% clean_names() %>%
  rename(ref_area = ca_name) %>%
  mutate(
    year = parse_integer(str_sub(ISOweek(date), start = 1, end = 4)),  # parse ISO year, otherwise the first few days of 2021 will belong to 2021 erroneously!
    week_number = parse_integer(str_sub(ISOweek(date), start = 7, end = 8)),
    ref_area = phsmethods::match_area(ca)  # convert to standard LA names, jsut in case they weren't already!
    )
```

# Calculate case counts: weekly counts to match weekly death reporting

Note: the cumulative case counts have already been calculated, we just need to subset them to match the weeks. This is not trivial - the death counts cover an entire week starting from the "w/c date"; the cumulative cases for that week could be taken either at the start, the end of the week, or the start of the following week even!

However, when calculating weekly positive cases we can simply take the maximum of that week's cumulative count - that will be the cumulative count at the end of the week!

Note also that the `crude_rate_positive_per100k` represents the cumulative rate!

```{r}
weekly_covid_cases_hb <-
  cases_hb %>%
  group_by(year, week_number, ref_area) %>%
  summarise(
    weekly_positive = sum(daily_positive),
    cumulative_positive = max(cumulative_positive),
    crude_rate_positive_per100k = max(crude_rate_positive),
    .groups = "drop"
  ) %>%
  mutate(
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)
    )

## extract Scotland-wide data and remove from HB split
weekly_covid_cases_overall <- weekly_covid_cases_hb %>% filter(ref_area=="Scotland")
weekly_covid_cases_hb <- weekly_covid_cases_hb %>% filter(ref_area!="Scotland")

weekly_covid_cases_la <-
  cases_la %>%
  group_by(year, week_number, ref_area) %>%
  summarise(
    weekly_positive = sum(daily_positive),
    cumulative_positive = max(cumulative_positive),
    crude_rate_positive_per100k = max(crude_rate_positive),
    .groups = "drop"
  ) %>%
  mutate(
    date_w_c = compute_start_date_from_week_number(week_number = week_number, year = year),
    week_number_run_over = if_else(year == 2021, 53L + week_number, week_number)
    )
```


# Comparing geographic areas by case counts

We can use the yearly cumulative case count to group geographic areas by how many cases they've had by the end of 2020.

```{r}
cumulative_case_2020_based_grouping_la <-
  weekly_covid_cases_la %>% 
  filter(ref_area!="Scotland") %>%
  filter(year == 2020) %>% 
  filter(week_number == max(week_number)) %>%  # keep last week
  select(ref_area, cumulative_positive, crude_rate_positive_per100k)

cumulative_case_2020_based_grouping_hb <-
  weekly_covid_cases_hb %>% filter(year == 2020) %>% 
  filter(ref_area!="Scotland") %>%
  filter(year == 2020) %>% 
  filter(week_number == max(week_number)) %>%  # keep last week 
  select(ref_area, cumulative_positive, crude_rate_positive_per100k)

k_means_clustering_cases_and_per100k_2020_hb <- map(
  .x = 2:4,
  .f = ~kmeans(x=cumulative_case_2020_based_grouping_hb %>% select(cumulative_positive, crude_rate_positive_per100k), centers = .x, nstart = 1e3)
) %>% set_names(nm=paste0("k",2:4))

clusters_hb <-
  bind_cols(
    cumulative_case_2020_based_grouping_hb %>% select(ref_area),
    map_dfc(.x = k_means_clustering_cases_and_per100k_2020_hb, .f = function(x) return(x$cluster))
  )

cumulative_case_2020_based_grouping_hb <-
  cumulative_case_2020_based_grouping_hb %>%
  left_join(clusters_hb, by="ref_area") %>%
  mutate(
    quartiles_cases = ntile(cumulative_positive, n=4),
    quartiles_per100k = ntile(crude_rate_positive_per100k, n=4)
  )

# TODO: apply to LA also!


hb_cases_plots <- list()

hb_cases_plots$cumulative_cases_vs_per100k <-
  cumulative_case_2020_based_grouping_hb %>%
  ggplot(data=., aes(x=cumulative_positive, y=crude_rate_positive_per100k, label=ref_area)) +
  geom_point() +
  geom_label_repel() +
  # theme_minimal() +
  labs(
    x="COVID cases",
    y="COVID cases per 100,000 population",
    title="Cases vs. population rate"
  ) +
  NULL

hb_cases_plots$cumulative_cases_vs_per100k_log10 <-
  cumulative_case_2020_based_grouping_hb %>%
  ggplot(data=., aes(x=cumulative_positive, y=crude_rate_positive_per100k, label=ref_area)) +
  geom_point() +
  geom_label_repel() +
  # theme_minimal() +
  labs(
    x="COVID cases (log)",
    y="COVID cases per 100,000 population (log)",
    title="Cases vs. population rate (log scale axes)"
  ) +
  scale_x_log10() +
  scale_y_log10() +
  NULL

hb_cases_plots$cumulative_cases_vs_per100k_quartiles_cases <-
  cumulative_case_2020_based_grouping_hb %>%
  ggplot(data=., aes(x=cumulative_positive, y=crude_rate_positive_per100k, label=ref_area, shape=factor(quartiles_cases))) +
  geom_point(size=3, aes(colour=factor(quartiles_cases))) +
  scale_colour_viridis_d() +
  geom_label_repel() +
  # theme_minimal() +
  labs(
    x="COVID cases",
    y="COVID cases per 100,000 population",
    title="Cases vs. population rate"
  ) +
  NULL

hb_cases_plots$cumulative_cases_vs_per100k_quartiles_cases <-
  cumulative_case_2020_based_grouping_hb %>%
  ggplot(data=., aes(x=cumulative_positive, y=crude_rate_positive_per100k, label=ref_area, shape=factor(quartiles_per100k))) +
  geom_point(size=3, aes(colour=factor(quartiles_cases))) +
  scale_colour_viridis_d() +
  geom_label_repel() +
  # theme_minimal() +
  labs(
    x="COVID cases",
    y="COVID cases per 100,000 population",
    title="Cases vs. population rate",
    colour = "Quartile (Cases per 100,000)"
  ) +
  NULL

hb_cases_plots$cumulative_cases_vs_per100k_k2 <-
  cumulative_case_2020_based_grouping_hb %>%
  ggplot(data=., aes(x=cumulative_positive, y=crude_rate_positive_per100k, label=ref_area, shape=factor(k2))) +
  geom_point(size=3, aes(colour=factor(k2))) +
  scale_colour_viridis_d() +
  geom_label_repel() +
  # theme_minimal() +
  labs(
    x="COVID cases",
    y="COVID cases per 100,000 population",
    title="Cases vs. population rate"
  ) +
  NULL


hb_cases_plots$cumulative_cases_vs_per100k_k3 <-
  cumulative_case_2020_based_grouping_hb %>%
  ggplot(data=., aes(x=cumulative_positive, y=crude_rate_positive_per100k, label=ref_area, shape=factor(k3))) +
  geom_point(size=3, aes(colour=factor(k3))) +
  scale_colour_viridis_d() +
  geom_label_repel() +
  # theme_minimal() +
  labs(
    x="COVID cases",
    y="COVID cases per 100,000 population",
    title="Cases vs. population rate"
  ) +
  NULL


hb_cases_plots$cumulative_cases_vs_per100k_k4 <-
  cumulative_case_2020_based_grouping_hb %>%
  ggplot(data=., aes(x=cumulative_positive, y=crude_rate_positive_per100k, label=ref_area, shape=factor(k4))) +
  geom_point(size=3, aes(colour=factor(k4))) +
  scale_colour_viridis_d() +
  geom_label_repel() +
  # theme_minimal() +
  labs(
    x="COVID cases",
    y="COVID cases per 100,000 population",
    title="Cases vs. population rate"
  ) +
  NULL


hb_cases_plots_assembled <- patchwork::wrap_plots(hb_cases_plots, ncol = 2)

hb_cases_plots_assembled
```




# Calculate historical averages, minima & maxima

Due to the counting of weeks, most years have 52 weeks with some years (2015 & 2020) having 53. Therefore we need to decide how to deal with week 53 in 2020 since only 2015 has a corresponding weekly count. The solution used here is to calculate a weekly rate for week 53 from week 53 in 2015, and week 52 in 2016-2019 - this represents the "last week of the year", which includes December 31st.

```{r, warning=FALSE}
map2_dfr(
  .x = list(past_deaths_overall, past_deaths_hb, past_deaths_la, past_deaths_sex_age),
  .y = c("overall","health_board","council_area","sex_age"),
  .f = function(data_tbl, name) {
    data_tbl %>%
      mutate(dataset=name,year=as.numeric(year)) %>%
      filter(year %in% 2016:2019 & week_number==53) %>%
      count(dataset,year)
  }
) %>% 
  pivot_wider(names_from=year,values_from=n) %>%
  knitr::kable(caption = "Number of entries by dataset for week number 53 in years 2016-2019 (which only had 52 weeks). Only the 'overall' historical deaths dataset has week 53 entries for years with 52 weeks, and all the entries are for 0 deaths.")

## helper function that creates week 53 data by taking week 52 in years with no year 53 and relabels it as 53
## CAUTION: only use this for computing averages! otherwise it's making up data that wasnae there
create_week_53_data_for_years_with_52_weeks <- function(data_tbl) {
  real_data <-
    data_tbl %>%
    filter(!(year %in% 2016:2019 & week_number==53))  # remove any entries for week 53 in years with 52 weeks - in some datasets they existed but had 0 listed
  fake_data <-
    data_tbl %>%
    filter(year %in% 2016:2019 & week_number==52) %>%
    mutate(week_number=53)
  return(
    bind_rows(
      real_data,
      fake_data
    )
  )
}

historical_average_overall <-
  past_deaths_overall %>%
  filter(year!="average") %>%  # remove averages
  group_by(year, week_number) %>%  # remove week 53 if it was 0 for all places  - this means there was no week 53!
  filter(!all(number_of_deaths==0 & week_number==53)) %>%
  ungroup %>%
  create_week_53_data_for_years_with_52_weeks %>%
  ungroup %>%
  group_by(week_number,place_of_death) %>% 
  summarise(
    across(number_of_deaths, .fns = list(mean=mean,min=min,max=max)),
    .groups = "drop"
  ) %>% rename_all(~str_replace_all(.x, pattern = "number_of_deaths", replacement = "deaths"))


week_53_text <- "Due to the way ISO 8601 counts weeks, only 2015 in the 2015-2019 period had 53 weeks; averages for week 53 were computed from figures for week 53 in 2015 and week 52 for 2016-2019."

# TODO: weekly averages may be too detailed for this level od subcategorising!

historical_average_hb <-
  past_deaths_hb %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, ref_area
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_la <-
  past_deaths_la %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, ref_area
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_sex_age <-
  past_deaths_sex_age %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_age <-
  past_deaths_age %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, age
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

historical_average_sex <-
  past_deaths_sex %>%
  create_week_53_data_for_years_with_52_weeks() %>%
  group_by(
    week_number, place_of_death, sex
  ) %>%
  summarise(
    deaths_mean = mean(number_of_deaths),
    deaths_min = min(number_of_deaths),
    deaths_max = max(number_of_deaths),
    .groups = "drop"
  )

compute_historical_annual_average_deaths <- function(data_tbl, ...) {
  grouping_vars <- enquos(...)
  data_tbl %>%
    group_by(year, place_of_death, !!!grouping_vars) %>%
    summarise(  # calculate annual totals first...
    number_of_deaths = sum(number_of_deaths), 
    .groups = "keep"
  ) %>%
  ungroup(year) %>%  # remove year as grouping to average over year now
  summarise(
    annual_deaths_mean = mean(number_of_deaths),
    annual_deaths_min = min(number_of_deaths),
    annual_deaths_max = max(number_of_deaths),
    .groups = "drop"
  )
}


historical_annual_average_overall <-
  past_deaths_overall %>%
  compute_historical_annual_average_deaths()

historical_annual_average_hb <-
  past_deaths_hb %>%
  compute_historical_annual_average_deaths(ref_area)

historical_annual_average_la <-
  past_deaths_la %>%
  compute_historical_annual_average_deaths(ref_area)

historical_annual_average_sex_age <-
  past_deaths_sex_age %>%
  compute_historical_annual_average_deaths(sex, age)

historical_annual_average_sex <-
  past_deaths_sex %>%
  compute_historical_annual_average_deaths(sex)

historical_annual_average_age <-
  past_deaths_age %>%
  compute_historical_annual_average_deaths(age)
```


## Check weekly historic averages against NRS computed data

```{r}
weekly_deaths_overall %>%
  filter(sex=="all" & age=="all") %>%
  left_join(historical_average_overall) %>%
  select(year, week_number, place_of_death, deaths_nrs_past_average_all_causes, deaths_mean) %>%
  filter(round(deaths_nrs_past_average_all_causes) != round(deaths_mean)) %>%
  knitr::kable(caption = "Subset of weekly deaths where calculated mean deaths 2015-2019 differed between the COVID-19 related deaths file and the weekly deaths file (i.e. all other entries had the same figures!). Week 53 was computed as the average of deaths in week 53 in 2015 and week 52 in 2016-2019. For all the other datasets the mean deaths computed agree!")
```


# Calculate moving averages (rolling mean) over multiple weeks

Once data are broken down by region there are very small figures on a weekly basis, so we can compute a moving average over several weeks instead. This is different to merging figures into 2-week chunks, for example, as information from consecutive weeks will overlap.

The average will be computed to the "left" of the current value (a week's moving average is the average of values at this week + n-1 past weeks, or "right" aligned).

Moving averages for historical data will be computed over the previously computed weekly means & ranges. Computing moving averages over historical ranges produces wider spread data than computing ranges of moving averages (see `order_of_min_max_rolling_mean.R`).


```{r}
weeks_to_average <- 2

## compute moving average over weekly data, using average over k weeks
## using historical data to compute the moving average in the first few weeks of current data
## Note: historical data needs to be the non-summarised (raw) data!
## to compute moving average in first few week(s) of year, we add in the previous years' data and code the weeks so that they retain the right order
## i.e. in 2020 the week_number_run_over starts at 1, and the last week of 2019 is coded as 0, the 2nd last as -1, etc.
## once the moving average has been computed, we remove the past data;
## this approach works for 2021 data seamlessly, using the last weeks of 2020 for the moving average in 2021!
compute_moving_average_for_current_data <- function(current_data, historical_data) {
  bind_rows(
    historical_data %>%  # add historical data and format it so that it matches current data
      filter(year == 2019) %>%  # keep only last year before 2020
      rename(deaths_all_causes = number_of_deaths) %>%  # in historical deaths there is no split between covid/non-covid so we rename to all cause deaths
      mutate(week_number_run_over = -(52-week_number)),
    current_data
  ) %>%
    arrange(week_number_run_over) %>%  # just in case the order got messed up, re-order by week_number_run_over for the computation
    group_by_all() %>% ungroup(matches("^deaths_|week|date|year")) %>%  # clever way of getting grouping by ref_area, sex, age, whatever is available
    mutate(across(
        .cols = matches("^deaths_"), 
        .fns = ~zoo::rollmean(.x, k=weeks_to_average, fill=NA, align="right"), 
        .names = "ma{weeks_to_average}w_{.col}"
        )
    ) %>%
    ungroup %>%
    filter(year > 2019)  # keep only current data
}

rolling_deaths_hb <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_hb, historical_data = past_deaths_hb)

rolling_deaths_la <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_la, historical_data = past_deaths_la)

rolling_deaths_sex_age <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_sex_age, historical_data = past_deaths_sex_age)

rolling_deaths_age <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_age, historical_data = past_deaths_age)

rolling_deaths_sex <-
  compute_moving_average_for_current_data(current_data = weekly_deaths_sex, historical_data = past_deaths_sex)



## inspect the calculations  
rolling_deaths_la %>% filter(week_number_run_over %in% c(1:3,52:54) & str_detect(ref_area,"Glasgow") & place_of_death=="Hospital") %>% select(year, week_number_run_over, ref_area, place_of_death, deaths_all_causes, ma2w_deaths_all_causes) %>% knitr::kable(caption="Showing how rolling average was computed: week 1 is average of week 52 of 2019 (not shown) and week 1 of 2020; week 2 is average of weeks 1 & 2, etc.")

rolling_deaths_sex_age %>% filter(week_number_run_over %in% c(1:3,52:54) & str_detect(sex,"F") & age == "65-74" & place_of_death=="Hospital") %>% select(year, week_number_run_over, sex, age, place_of_death, deaths_all_causes, ma2w_deaths_all_causes) %>% knitr::kable(caption = "Showing how rolling average was computed: week 1 is average of week 52 of 2019 (not shown) and week 1 of 2020; week 2 is average of weeks 1 & 2, etc.")



## helper function that takes historical data and computes a moving average over k weeks
## with the additional trick of using the last week of all the years as the week prior to the first week
## strictly speaking we should be using the last week(s) of 2014 to compute the moving average for the first week(s) in 2015, depending on k; and we shouldn't be using the last week of 2019 in the computation either
## however, the overall effect of this is small since we're averaging over the entire 2015-2019 period
## the inaccuracy of this approach increases with increasing k
## the solution for fixing this is straightforward - just download 2014 data as well, and merge the "current" data and the historical data, and then perform the moving average calculation as usual
compute_moving_average_for_historical_data <- function(historical_data) {
  last_week_in_previous_year_required <- 53 + 2 - weeks_to_average  # this computes the last week needed from the previous year: if averaging over 2 weeks, we need week 3, if over 3 weeks, the lat week needed is 52, etc.
  bind_rows(
    historical_data %>%  # keep last week from all years and convert it to week 0
      filter(week_number %in% last_week_in_previous_year_required:53) %>% 
      mutate(week_number = week_number - 53),  # set week number for data in previous to negative numbers but retaining order 
    historical_data
  ) %>%
  arrange(week_number) %>%  # sort in ascending order of week_number
  group_by_all() %>% ungroup(matches("^deaths_"),week_number) %>%
  mutate(across(
      .cols = matches("^deaths_"), 
      .fns = ~zoo::rollmean(.x, k=weeks_to_average, fill=NA, align="right"), 
      .names = "ma{weeks_to_average}w_{.col}"
      )
  ) %>%
  ungroup %>%
  filter(week_number!=0)
}

historical_average_hb <- compute_moving_average_for_historical_data(historical_average_hb)
historical_average_la <- compute_moving_average_for_historical_data(historical_average_la)
historical_average_sex_age <- compute_moving_average_for_historical_data(historical_average_sex_age)
historical_average_sex <- compute_moving_average_for_historical_data(historical_average_sex)
historical_average_age <- compute_moving_average_for_historical_data(historical_average_age)
```


# Merge weekly COVID/non-COVID-related deaths in 2020/2021 with historic death rates

```{r}
## compute rolling average
merged_deaths_overall <-
  weekly_deaths_overall %>%
  filter(sex=="all" & age=="all") %>%
  inner_join(historical_average_overall %>% mutate(sex = "all", age = "all"),  # only merge for aggregated data b/c that's all we have!
            by = c("place_of_death", "week_number", "sex", "age"))

merged_deaths_hb <-
  rolling_deaths_hb %>%  # use data with rolling movingincluded
  inner_join(historical_average_hb, by = c("week_number","ref_area","place_of_death"))

merged_deaths_la <-
  rolling_deaths_la %>%  # use data with rolling movingincluded
  inner_join(historical_average_la, by = c("week_number","ref_area","place_of_death"))

merged_deaths_sex_age <-
  rolling_deaths_sex_age %>%  # use data with rolling movingincluded
  inner_join(historical_average_sex_age, by = c("place_of_death", "week_number", "sex", "age"))

merged_deaths_sex <-
  rolling_deaths_sex %>%
  inner_join(historical_average_sex, by = c("place_of_death", "week_number", "sex"))

merged_deaths_age <-
  rolling_deaths_age %>%
  inner_join(historical_average_age, by = c("place_of_death", "week_number", "age"))
```


## Weekly deaths including past weekly deaths

For this dataset, we simply `bind_rows` weekly deaths by year and place of death with past weekly deaths by year and location. Note that past data for years with 52 weeks includes an entry of 0 deaths for week 53, so we'll remove them, otherwise the date computation is thrown off!

```{r}
weekly_deaths_current_and_past <-
  bind_rows(
    weekly_deaths_overall %>%
    filter(sex=="all" & age=="all" & place_of_death!="All") %>%  # keep only aggregated values over sex & age
    select(year, week_number, week_number_run_over, place_of_death, matches("deaths"), -deaths_nrs_past_average_all_causes)
    ,
    past_deaths_overall %>%
      rename(deaths_all_causes = number_of_deaths) %>%
      filter(place_of_death!="All" & year!="average") %>%  # remove aggregated entries
      mutate(year = as.integer(year)) %>%
      filter(!(year %in% 2016:2019 & week_number==53))  # remove week 53 entries from years 2016-2019
  ) %>%
  mutate(date_w_c = compute_start_date_from_week_number(week_number = week_number, year_number = year))
```



# Annual deaths for 2020 & 2021

For visualising data using maps, we need to compute data for the entire year. Note: the non-covid and covid-related deaths in 2020 don't add up to all cause deaths due to the covid status only starting in week 12!

```{r}
compute_total_deaths_in_year <- function(data_tbl, ...) {
  grouping_vars <- enquos(...)
  data_tbl %>%
    group_by(year, place_of_death, !!!grouping_vars) %>%
    summarise(across(.cols = c(deaths_all_causes, deaths_covid_related, deaths_non_covid), .fns = ~sum(.x,na.rm=TRUE)), .groups = "drop") %>%  # compute sums of all types of death
    mutate(deaths_all_causes_since_covid = deaths_covid_related + deaths_non_covid)  # compute a smaller number of all-cause deaths since covid started (over 2020, covid- and non-covid-related deaths don't add up to all-cause deaths because pre-covid deaths are included also!)
}

compute_ratio_of_annual_deaths_to_historical <- function(data_tbl) {
  data_tbl %>%
    mutate(
      ratio_annual_deaths_to_historical_mean = deaths_all_causes / annual_deaths_mean,
      ratio_annual_deaths_to_historical_min = deaths_all_causes / annual_deaths_min,
      ratio_annual_deaths_to_historical_max = deaths_all_causes / annual_deaths_max
    )
}

total_deaths_la <-
  merged_deaths_la %>%
  compute_total_deaths_in_year(ref_area) %>%
  left_join(historical_annual_average_la, by = c("place_of_death", "ref_area")) %>%
  compute_ratio_of_annual_deaths_to_historical

total_deaths_hb <-
  merged_deaths_hb %>%
  compute_total_deaths_in_year(ref_area) %>%
  left_join(historical_annual_average_hb, by = c("place_of_death", "ref_area")) %>%
  compute_ratio_of_annual_deaths_to_historical

total_deaths_sex <-
  merged_deaths_sex %>%
  compute_total_deaths_in_year(sex) %>%
  left_join(historical_annual_average_sex, by = c("place_of_death", "sex")) %>%
  compute_ratio_of_annual_deaths_to_historical

total_deaths_age <-
  merged_deaths_age %>%
  compute_total_deaths_in_year(age) %>%
  left_join(historical_annual_average_age, by = c("place_of_death", "age")) %>%
  compute_ratio_of_annual_deaths_to_historical

total_deaths_overall <-
  merged_deaths_overall %>%
  compute_total_deaths_in_year() %>%
  left_join(historical_annual_average_overall, by = c("place_of_death")) %>%
  compute_ratio_of_annual_deaths_to_historical
```


# Constants about latest data available

```{r}
## constants for use in graphs & annotations
weeks_available_2021 <- max(merged_deaths_age$week_number[merged_deaths_age$year==2021])
most_recent_date_available_2021 <- max(merged_deaths_age$date_w_c)
earliest_date <- min(merged_deaths_age$date_w_c)
```


# Comparisons of annual rates with current rates

```{r}
table_current_deaths_compared_to_past <-
  bind_rows(
    ## all available data
    merged_deaths_overall %>%
      filter(age == "all" &
               sex == "all"
             ) %>% 
      group_by(year, place_of_death, week_number) %>%
      summarise(
        deaths_all_causes = sum(deaths_all_causes),
        # deaths_non_covid = sum(deaths_non_covid, na.rm = TRUE),
        deaths_covid_related = sum(deaths_covid_related, na.rm = TRUE),
        .groups = "drop"
      ) %>% 
      mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related) %>%
      left_join(
        past_deaths_overall %>% filter(year != "average") %>% group_by(week_number, place_of_death) %>% summarise(
                                           average_weekly_deaths = sum(number_of_deaths) / 5,
                                           .groups = "drop"
                                         ),
        by = c("week_number", "place_of_death")
      ) %>% 
      group_by(place_of_death) %>%
      summarise(
        period = glue::glue("Data from week 1, 2020 to week {weeks_available_2021}, 2021"),
        deaths_all_causes = sum(deaths_all_causes),
        deaths_non_covid = sum(deaths_non_covid, na.rm = TRUE),
        deaths_covid_related = sum(deaths_covid_related, na.rm = TRUE),
        mean_annual_deaths_2015_2019 = sum(average_weekly_deaths),
        .groups = "drop"
      )
    ,
    ## 2020 only
    merged_deaths_overall %>%
      filter(age == "all" &
               sex == "all" &
               year == 2020
             ) %>% 
      group_by(place_of_death) %>%
      summarise(
        period = "2020",
        deaths_all_causes = sum(deaths_all_causes),
        deaths_covid_related = sum(deaths_covid_related, na.rm = TRUE),
        .groups = "drop"
      ) %>% 
      mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related) %>%
    left_join(
      historical_annual_average_overall %>% 
        select(place_of_death, mean_annual_deaths_2015_2019 = annual_deaths_mean),
      by = "place_of_death"
    )
    ,
    ## 2020 from week 12 onwards (including week 12) - pandemic part of 2020
    merged_deaths_overall %>%
      filter(
        age == "all" &
          sex == "all" &
          year == 2020 & week_number >= 12
      ) %>%
      group_by(place_of_death) %>%
      summarise(
        period = "2020, week 12 - week 53",
        deaths_all_causes = sum(deaths_all_causes),
        deaths_covid_related = sum(deaths_covid_related, na.rm = TRUE),
        .groups = "drop"
      ) %>% 
    mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related) %>%
    left_join(
      past_deaths_overall %>% 
        filter(week_number >= 12 & year != "average") %>%
        group_by(place_of_death) %>%
        summarise(mean_annual_deaths_2015_2019 = sum(number_of_deaths) / 5),
      by = "place_of_death"
    )
  ) %>%
  mutate(
    ratio_deaths_all_causes_to_historical = deaths_all_causes / mean_annual_deaths_2015_2019,
    ratio_non_covid_deaths_to_historical = deaths_non_covid / mean_annual_deaths_2015_2019,
    proportion_covid_deaths = deaths_covid_related / deaths_all_causes
  )

write_csv(x = table_current_deaths_compared_to_past, file = file.path(dir_outputs, "annual_death_rates_comparison_with_historical_deaths.csv"))

table_current_deaths_compared_to_past %>% knitr::kable(caption = "Comparing annual home death rate during COVID pandemic to historical deaths at home")
```


# Comparing historical rates of home death to total death to 2020/2021

```{r}
proportions_of_historical_deaths_by_place <-
  past_deaths_overall %>% 
  group_by(year, place_of_death) %>% summarise(number_of_deaths = sum(number_of_deaths), .groups="drop") %>%
  filter(place_of_death != "All" & !is.na(as.integer(year))) %>%
  group_by(year) %>%
  mutate(
    total_deaths = sum(number_of_deaths)
  ) %>%
  ungroup %>%
  mutate(proportion_of_total = number_of_deaths / total_deaths, year=as.integer(year))

proportions_of_current_deaths_by_place <-
  total_deaths_overall %>%
  select(year, place_of_death, number_of_deaths = deaths_all_causes) %>%
  filter(place_of_death != "All") %>%
  group_by(year) %>%
  mutate(
    total_deaths = sum(number_of_deaths)
  ) %>%
  ungroup %>%
  mutate(proportion_of_total = number_of_deaths / total_deaths)


merged_proportions_of_deaths_by_place <-
  bind_rows(
    proportions_of_historical_deaths_by_place,
    proportions_of_current_deaths_by_place
  )
```

## Including non-COVID deaths

Note: non-covid deaths are defined as all-cause deaths minus covid-related deaths. Otherwise the number of non-covid deaths only includes non-covid deaths once covid-related deaths started being reported in 2020 (week 12).

```{r}
proportions_of_current_non_covid_deaths_by_place <-
  total_deaths_overall %>%
  mutate(deaths_non_covid = deaths_all_causes - deaths_covid_related) %>%
  select(year, place_of_death, number_of_deaths = deaths_non_covid) %>%
  filter(place_of_death != "All") %>%
  group_by(year) %>%
  mutate(
    total_deaths = sum(number_of_deaths)
  ) %>%
  ungroup %>%
  mutate(proportion_of_total = number_of_deaths / total_deaths)

merged_proportions_of_non_covid_deaths_by_place <-
  bind_rows(
    proportions_of_historical_deaths_by_place,  # all historical deaths are non-covid!
    proportions_of_current_non_covid_deaths_by_place
  )
```


# Visualisations

## Common elements

```{r}
loadfonts()  # load imported fonts
# Sys.setenv(R_GSCMD = "C:/Program Files/gs/gs9.27/bin/gswin64c.exe")  # set the location of the GS file  # this not needed, just use device=device_cairo for pdfs in ggsave

theme_set(theme_minimal(base_size = 12) +
            theme(panel.grid.minor = element_blank(),
                  axis.title.y = element_text(margin = margin(0, 20, 0, 0)),  # remove gap to the left of y axis title and below the x axis title
                  axis.title.x = element_text(margin = margin(20, 0, 0, 0)),
                  text=element_text(family="Calibri")
            ))


date_range_text <- glue::glue("Data from w/c {format(min(weekly_deaths_overall$date_w_c), '%d %B %Y')} to w/c {format(max(weekly_deaths_overall$date_w_c), '%d %B %Y')} (inclusive).")

dashed_line_historical_range_text <- "Range of deaths 2015-19 shown as shaded area; mean shown as dashed line."

only_2020_text <- glue::glue("Data from 2020 included, starting with w/c {format(earliest_date)}.")
only_2021_text <- glue::glue("Data for 2021 only include weeks 1-{format(weeks_available_2021)} (w/c {format(most_recent_date_available_2021)}).")

source_nrs_text <- "Source: National Records of Scotland"
source_phs_text <- "Source: Public Health Scotland"

death_registrations_text <- "Note: all figures are based on date of registration."

vertical_line_text <- "Vertical dotted line at week number 54 represents start of 2021."

```

## Function to save files to multiple formats

Saving to multiple formats is easy enough - the trouble is with saving PDF files with custom fonts, since they need to be embedded in the .pdf file. This requires:

* telling R where to load the font from, using `extrafont::font_import()` - this was done in a previous step
* registering fonts with R using `extrafont::loadfonts()` - note: this isn't strictly necessary, since once imported, `extrafont` keeps track of fonts to load when the `extrafont` package is loaded
* ~~telling R where the `gs` executable is, i.e. the installation of ghostscript on the current machine~~
* ~~embedding the fonts in the `.pdf` files once they've been written, using `extrafont::embed_fonts()`~~
* instead of manually embedding fonts (which resulted in garbled text on my setup!), just use `device=device_cairo` as an argument to `ggsave()` when saving `.pdf` files and it just works

```{r}
save_output_file <- function(filename, extensions, plot, width, height, units, dpi) {
  
walk(
  .x = extensions,
  .f = ~function(ext) {
    if (tolower(ext)==".pdf") device <- cairo_pdf
    
  ggsave(filename = paste0(filename, .x), plot = plot, width = width, height = height, units = units, dpi = dpi, device = if (.x==".pdf") cairo_pdf else NULL)
  }
)

# TODO: remove below bit, not needed when using device=device_cairo
# if (any(str_detect(string = tolower(extensions), pattern = "pdf"))) {
#   pdf_filename <- paste0(filename, extensions[which(any(str_detect(string = tolower(extensions), pattern = "pdf")))])
#   embed_fonts(file = pdf_filename)  # overwrites file with one with font embedded
# }
# invisible(filename)  # return invisibly
}

```


# Proportion home deaths over time

```{r}
figure_proportion_home_deaths_over_time <-
  merged_proportions_of_deaths_by_place %>%
  mutate(place_of_death = factor(x = place_of_death, levels = order_of_place_of_death_levels[c(1,3,2,4)])) %>%  # move home to 2nd position to match order in plot
  ggplot(., aes(x=year, y=proportion_of_total, colour=place_of_death)) +
  geom_point() +
  geom_line(size = 1) +
  geom_text(data = ~filter(.x, year==2021), aes(x=2021.1, y=proportion_of_total, label="*"), inherit.aes = FALSE) +
  scale_x_continuous(breaks = 2015:2021) +
  scale_y_continuous(label = scales::percent) +
  scale_colour_viridis_d(option="C") +
  # theme_minimal() +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(
    x = "Year", y= "Proportion of yearly deaths (%)",
    colour = "",
    subtitle = paste0("* ",only_2021_text),
    caption = paste0(c(source_nrs_text),collapse="\n")
    ) +
  guides(colour = guide_legend(nrow=2)) +  # spread colour legend over two rows
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_proportion_home_deaths_over_time"), extensions = c(".pdf",".svg",".png"), plot = figure_proportion_home_deaths_over_time, width = 12, height = 10, units = "cm", dpi = 300)

figure_proportion_home_deaths_over_time
```


# Cumulative deaths

Note: I've left this unfinished, it doesn't tell a better story than the weekly figures!

```{r}
text_non_covid_deaths_equivalent_to_all_cause_before_wk12 <- "Note: all-cause deaths and non-covid deaths were considered equivalent before 2020, week 12"

text_annotation_cunulative_all_cause_deaths <- "Hospital all-cause deaths were within the historical range; home & care home deaths exceeded historical ranges."

# TODO: these figures over- and underestimate yearly cumulative deaths (because they use weekly min/max, as opposed to min/max of cumulative deaths)

figure_cumulative_deaths_by_place <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(!place_of_death %in% c("All","Other")) %>%
  mutate(place_of_death = factor(place_of_death, levels = c("Hospital", "Home & other non-institution", "Care home"))) %>%  # needs to be factor with same levels, otherwise it messes up level order when added as geom_text later!)
  mutate(deaths_non_covid = if_else(condition = is.na(deaths_non_covid), true = deaths_all_causes, false = deaths_non_covid)) %>%  # replace NA in non-covid deaths with all cause deaths - before covid, non-covid deaths are equivalent to all deaths 
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>%
  mutate(deaths_type = case_when(
    deaths_type == "deaths_all_causes" ~ "All-cause deaths",
    deaths_type == "deaths_non_covid" ~ "Non-COVID deaths",
    TRUE ~ NA_character_
  )) %>%
  group_by(place_of_death, deaths_type) %>%
  mutate(
    cumulative_deaths = cumsum(replace_na(deaths, replace = 0)),
    cumulative_historical_mean = cumsum(replace_na(deaths_mean, replace = 0)),
    cumulative_historical_min = cumsum(replace_na(deaths_min, replace = 0)),
    cumulative_historical_max = cumsum(replace_na(deaths_max, replace = 0))
    ) %>%
  ungroup %>%
  ggplot(aes(x = date_w_c)) +
  scale_x_date(date_labels = "%d-%m-%y", date_breaks = "8 weeks", limits = c(earliest_date, most_recent_date_available_2021)) +
  scale_y_continuous(labels = function(x) format(x, big.mark = ",")) +
  geom_ribbon(aes(ymin = cumulative_historical_min, ymax = cumulative_historical_max, fill = place_of_death), alpha = 0.4) +
  geom_line(aes(y = cumulative_historical_mean, colour = place_of_death), linetype = "dashed", alpha = 0.8, show.legend = FALSE) +
  geom_line(aes(y = cumulative_deaths, colour = place_of_death)) +
  facet_wrap(~deaths_type) +
  scale_colour_viridis_d(option = "C") +
  scale_fill_viridis_d(option = "C") +
  theme(
    legend.position = "top",
    plot.caption = element_text(size = 10, colour = "gray60"),
    plot.margin = margin(5, 15, 5, 5),
    axis.text.x = element_text(angle = 60, colour = "gray40", vjust=1, hjust=1)
  ) +
  labs(x = "Date w/c",
       y = "Cumulative deaths (N)",
       title = "Cumulative deaths by place of death",
       # subtitle = paste0(c(only_2020_text,light_shaded_area_shows_difference),collapse="\n"),
       caption = paste0(c(text_non_covid_deaths_equivalent_to_all_cause_before_wk12,death_registrations_text,source_nrs_text), collapse="\n")
  ) +
  NULL
  
save_output_file(filename = paste0(dir_outputs,"/figure_cumulative_deaths_by_place"), extensions = c(".pdf",".svg",".png"), plot = figure_cumulative_deaths_by_place, width = 15, height = 12, dpi = 300, units = "cm")

figure_cumulative_deaths_by_place
```


# Number of deaths visualisations

## Total deaths in 2020 by age group & place of death

```{r, fig.width=12, fig.height=7, warning=FALSE}
bar_and_error_bars_2020_text <- "Bars are 2020 all-cause deaths, point and bars shows annual mean and range 2015-2019"
excluded_other_place_2020 <- glue::glue("Excluding records with 'Other' place of death, N={total_deaths_age %>% filter(year==2020 & place_of_death=='Other') %>% .$deaths_all_causes %>% sum}")

light_shaded_area_shows_difference <- "Lighter area in the top of bar shows difference between 2020 deaths and historical maximum 2015-2019"

# TODO: make the distinction max vs 2020 figures clearer! maybe annotate?

figure_annual_deaths_by_age_group_2020 <-
  total_deaths_age %>% 
  filter(year==2020) %>%
  filter(place_of_death != "Other") %>%
  ggplot(aes(x = age, y = deaths_all_causes)) +
  # geom_col(fill = "#4477AA", alpha = 0.5, colour = "grey10") +
  geom_col(fill = "grey20", colour = "grey10", alpha = 0.5) +
  geom_col(aes(x=age, y=annual_deaths_max), fill = "#4477AA", colour = "grey10", alpha = 0.5) +  # historical maximum over the actual figure
  geom_point(aes(x=age, y=annual_deaths_mean)) +
  geom_errorbar(aes(x = age, ymin = annual_deaths_min, ymax = annual_deaths_max)) +
  facet_wrap(~place_of_death) +
  scale_y_continuous(labels = function(x) format(x,big.mark=",")) +
  labs(x = "Age",
       y = "Deaths (N)",
       title = "Deaths in 2020 by age group & place of death",
       subtitle = paste0(c(only_2020_text,light_shaded_area_shows_difference),collapse="\n"),
       caption = paste0(c(excluded_other_place_2020,bar_and_error_bars_2020_text,death_registrations_text,source_nrs_text), collapse="\n")
  )
  
save_output_file(filename = paste0(dir_outputs,"/figure_annual_deaths_by_age_group_2020"), extensions = c(".pdf",".svg",".png"), plot = figure_annual_deaths_by_age_group_2020, width = 12, height = 7, dpi = 300, units = "in")

figure_annual_deaths_by_age_group_2020
```


## Recorded deaths in Scotland, by week number & location, with annotations (after DH's plots)

```{r, fig.width=12, fig.height=9, warning=FALSE}
removed_other_category_text <- glue::glue("Excluding 'Other' institutional place of death, N={merged_deaths_overall %>% filter(sex == 'all' & age == 'all' & place_of_death == 'Other') %>% .$deaths_all_causes %>% sum} for weeks 1-{max(merged_deaths_overall %>% filter(year==2020) %>% .$week_number)} in 2020 and 1-{max(merged_deaths_overall %>% filter(year==2021) %>% .$week_number)} in 2021.")

annotations_figure_place_of_death <-
# datapasta::tribble_paste(merged_deaths_overall %>% select(place_of_death))
  tibble::tribble(
    ~place_of_death, ~x, ~y, ~label,
                 "Hospital", 20L, 850, "Shaded area shows range of 2015-2019 deaths; dashed line shows weekly average",
                 "Hospital", 25L, 250, "Hospital deaths dipped below historical minimum and remained low until Winter.",
                "Care home", 35L, 500, "After initial peak, deaths returned to historical range; non-Covid deaths remained low.",
                     "Home & other non-institution", 35L, 500, "The gap between historical high and both types of death at home was high throughout."
                  ) %>% 
  mutate(
    place_of_death = factor(place_of_death, levels = levels(merged_deaths_overall$place_of_death)),  # needs to be factor with same levels, otherwise it messes up level order when added as geom_text later!
    label = str_wrap(label, width = 40)
    )

figure_place_of_death_after_dh <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(!place_of_death %in% c("All","Other")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  geom_text(data = annotations_figure_place_of_death, aes(x=x,y=y, label=label)) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~place_of_death) +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, removed_other_category_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_place_of_death_after_dh"), extensions = c(".pdf",".svg",".png"), plot = figure_place_of_death_after_dh, width = 12, height = 9, dpi = 300, units = "in")

figure_place_of_death_after_dh
```

### Place of death with historic range, updated version

```{r, fig.width=12, fig.height=9, warning=FALSE}
## to put the arrows explaining historic range etc. only in one panel, need to construct a tibble to pass as data
annotations_figure_place_of_death_explaining_historic_range <- tribble(
   ~geom, ~place_of_death, ~label, ~x, ~y, ~xend, ~yend,
  "text", "Hospital", "Historic range (min & max)", 29, 850, NA, NA,
  "curve", "Hospital", NA, 29, 830, 32, 550,
  "text", "Hospital", "Historic mean", 22, 800, NA, NA,
  "curve", "Hospital", NA, 22, 780, 26, 510
) %>% 
  mutate(across(.cols = c("x","xend"), .fns = ~compute_start_date_from_week_number(week_number = .x, year_number = 2020))) %>%
  mutate(place_of_death = factor(place_of_death, levels = c("Hospital", "Home & other non-institution", "Care home")))  # needs to be factor with same levels, otherwise it messes up level order when added as geom_text later!)


figure_place_of_death <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(!place_of_death %in% c("All","Other")) %>%
  mutate(place_of_death = factor(place_of_death, levels = c("Hospital", "Home & other non-institution", "Care home"))) %>%  # needs to be factor with same levels, otherwise it messes up level order when added as geom_text later!)
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = date_w_c)) +
  annotate(geom = "rect", xmin = compute_start_date_from_week_number(week_number = 1, year_number = 2021), xmax = compute_start_date_from_week_number(week_number = weeks_available_2021, year_number = 2021), ymin = -Inf, ymax = Inf, fill = "grey90", alpha = 0.2) +  # shade area - geom_rect doesn't work here
  scale_x_date(date_labels = "%d-%m-%y", date_breaks = "8 weeks", limits = c(earliest_date, most_recent_date_available_2021)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", colour="grey20") +
  facet_grid(~place_of_death) +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(
    legend.position = "top",
    plot.caption = element_text(size = 10, colour = "gray60"),
    plot.margin = margin(5, 15, 5, 5),
    axis.text.x = element_text(angle = 60, colour = "gray40", vjust=1, hjust=1)
  ) +
  labs(x = "Date w/c",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(death_registrations_text,removed_other_category_text,source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       ) +
  ## annotate historic range
  geom_text(data = annotations_figure_place_of_death_explaining_historic_range %>% filter(geom=="text"), aes(x=x, y=y, label=label),  colour = "grey20", size = 8 / (14/5)) +  # the size is tricky
  geom_curve(data = annotations_figure_place_of_death_explaining_historic_range %>% filter(geom=="curve"), aes(x=x, y=y, xend=xend, yend=yend), colour = c("#4477aa", "grey20"), alpha = c(0.5, 1), curvature = 0.20, arrow = arrow(length = unit(0.2, "cm"))) +
  annotate(geom = "text", x=ymd("2021-01-07"), y=30, label = "2021", hjust = 0, colour = "grey40") +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_place_of_death"), extensions = c(".pdf",".svg",".png"), plot = figure_place_of_death, width = 28, height = 14, dpi = 300, units = "cm")

figure_place_of_death
```


## All of Scotland, deaths at home, for policy briefing

```{r, fig.width=12, fig.height=9, warning=FALSE}
# TODO: add start of lockdowns 1-3?
# TODO: what is that dip at week 38/39? not obvious - start of september was tier 4 restrictions in big LAs
total_deaths_at_home_in_period <- glue::glue("Total deaths at home N={format(merged_deaths_overall %>% filter(sex == 'all' & age == 'all' & place_of_death %in% c('Home & other non-institution')) %>% .$deaths_all_causes %>% sum, big.mark=',')}")

figure_deaths_at_home_policy_briefing <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", colour="grey20") +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  ylim(0, 600) +  # start scale at 0 for better understanding the scale of deaths
  facet_grid(~place_of_death) +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  annotate(geom = "text", label = total_deaths_at_home_in_period, x = 21, y = 575, hjust=0) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(dashed_line_historical_range_text,vertical_line_text, death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       ) +
  NULL

## figure for a bit less than half A4 page is approx 14*11cm
save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_policy_briefing"), extensions = c(".pdf",".svg",".png",".jpg"), plot = figure_deaths_at_home_policy_briefing, width = 14, height = 11, units = "cm", dpi = 300)

figure_deaths_at_home_policy_briefing
```


## All of Scotland, deaths at home - date axis

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = date_w_c)) +
  annotate(geom = "rect", xmin = compute_start_date_from_week_number(week_number = 1, year_number = 2021), xmax = compute_start_date_from_week_number(week_number = weeks_available_2021, year_number = 2021), ymin = -Inf, ymax = Inf, fill = "grey90", alpha = 0.2) +  # shade area - geom_rect doesn't work here
  scale_x_date(date_labels = "%d-%m-%y", date_breaks = "8 weeks", limits = c(earliest_date, most_recent_date_available_2021)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", colour="grey20") +
  ylim(0, 600) +  # start scale at 0 for better understanding the scale of deaths
  facet_grid(~place_of_death) +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60"), plot.margin = margin(5,15,5,5)) +
  labs(x = "Date w/c",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       ) +
  ## annotate historic range
  annotate(geom="text",x = compute_start_date_from_week_number(week_number = 10, year_number = 2020), y = 100, label = "Historic range (min & max)", colour = "grey20") +
  annotate(geom="curve",x = compute_start_date_from_week_number(week_number = 10, year_number = 2020), xend = compute_start_date_from_week_number(week_number = 14, year_number = 2020), y = 110, yend = 250, curvature = 0.20, colour = "#4477aa", alpha = 0.5, arrow = arrow(length = unit(0.2, "cm"))) +
  annotate(geom="text", x = compute_start_date_from_week_number(week_number = 20, year_number = 2020), y = 50, label = "Historic mean", colour = "grey20") +
  annotate(geom="curve",x = compute_start_date_from_week_number(week_number = 20, year_number = 2020), xend = compute_start_date_from_week_number(week_number = 25, year_number = 2020), y = 60, yend = 270, curvature = 0.20, colour = "grey20", linetype="dashed", arrow = arrow(length = unit(0.2, "cm"))) +
  ## annotate year
  geom_text(aes(x=ymd("2021-01-07"), y=30, label = "2021"), hjust = 0, colour = "grey40") +
  NULL

## figure for a bit less than half A4 page is approx 14*11cm
save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home"), extensions = c(".pdf",".svg",".png",".jpg"), plot = figure_deaths_at_home, width = 18, height = 15, units = "cm", dpi = 300)

figure_deaths_at_home
```



## All of Scotland, deaths at home - week number

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_wwek_number <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_vline(xintercept = 53.5, linetype = "dotted", colour="grey40", show.legend = FALSE) +  # line should be between last week 2020 and 1st week 2021
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", colour="grey20") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  ylim(0, 600) +  # start scale at 0 for better understanding the scale of deaths
  facet_grid(~place_of_death) +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       ) +
  ## annotate historic range
  geom_text(aes(x = 10, y = 100, label = "Historic range (min & max)"), colour = "grey20") +
  geom_curve(aes(x = 10, xend = 14, y = 110, yend = 250), curvature = 0.20, colour = "#4477aa", alpha = 0.5, arrow = arrow(length = unit(0.2, "cm"))) +
  geom_text(aes(x = 20, y = 50, label = "Historic mean"), colour = "grey20") +
  geom_curve(aes(x = 20, xend = 25, y = 60, yend = 270), curvature = 0.20, colour = "grey20", linetype="dashed", arrow = arrow(length = unit(0.2, "cm"))) +
  ## annotate year
  geom_text(aes(x=54, y=30, label = "2021"), hjust = 0, colour = "grey40") +
  NULL

## figure for a bit less than half A4 page is approx 14*11cm
save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_wwek_number"), extensions = c(".pdf",".svg",".png",".jpg"), plot = figure_deaths_at_home_wwek_number, width = 18, height = 15, units = "cm", dpi = 300)

figure_deaths_at_home_wwek_number
```



## Deaths at home in 2020, all of Scotland

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_2020 <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  filter(year == 2020) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~place_of_death) +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       # subtitle = date_range_text,
       subtitle = "Data from 2020 shown, starting with w/c 30 Dec 2019.",
       caption = paste0(c(death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_2020"), extensions = c(".pdf",".svg",".png"), plot = figure_deaths_at_home_2020, width = 12, height = 9, dpi = 300, units = "in")

figure_deaths_at_home_2020
```


## Deaths in hospital, date axis

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_in_hospital <-
  merged_deaths_overall %>%
  filter(sex == "all" & age == "all") %>%
  filter(place_of_death %in% c("Hospital")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = date_w_c)) +
  annotate(geom = "rect", xmin = compute_start_date_from_week_number(week_number = 1, year_number = 2021), xmax = compute_start_date_from_week_number(week_number = weeks_available_2021, year_number = 2021), ymin = -Inf, ymax = Inf, fill = "grey90", alpha = 0.2) +  # shade area - geom_rect doesn't work here
  scale_x_date(date_labels = "%d-%m-%y", date_breaks = "8 weeks", limits = c(earliest_date, most_recent_date_available_2021)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", colour="grey20") +
  # ylim(0, 600) +  # start scale at 0 for better understanding the scale of deaths
  facet_grid(~place_of_death) +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60"), plot.margin = margin(5,15,5,5)) +
  labs(x = "Date w/c",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       ) +
  ## annotate historic range
  annotate(geom = "text", x = compute_start_date_from_week_number(week_number = 29, year_number = 2020), y = 850, label = "Historic range (min & max)", colour = "grey20") +
  annotate(geom = "curve", x = compute_start_date_from_week_number(week_number = 29, year_number = 2020), xend = compute_start_date_from_week_number(week_number = 32, year_number = 2020), y = 830, yend = 550, curvature = 0.20, colour = "#4477aa", alpha = 0.5, arrow = arrow(length = unit(0.2, "cm"))) +
  annotate(geom = "text", x = compute_start_date_from_week_number(week_number = 22, year_number = 2020), y = 800, label = "Historic mean", colour = "grey20") +
  annotate(geom = "curve", x = compute_start_date_from_week_number(week_number = 22, year_number = 2020), xend = compute_start_date_from_week_number(week_number = 26, year_number = 2020), y = 780, yend = 510, curvature = 0.20, colour = "grey20", linetype="dashed", arrow = arrow(length = unit(0.2, "cm"))) +
  ## annotate year
  geom_text(aes(x=ymd("2021-01-07"), y=30, label = "2021"), hjust = 0, colour = "grey40") +
  NULL

## figure for a bit less than half A4 page is approx 14*11cm
save_output_file(filename = paste0(dir_outputs,"/figure_deaths_in_hospital"), extensions = c(".pdf",".svg",".png",".jpg"), plot = figure_deaths_in_hospital, width = 18, height = 15, units = "cm", dpi = 300)

figure_deaths_in_hospital
```



## Deaths at home, by health board

```{r, fig.width=12, fig.height=9, warning=FALSE}
island_health_boards_merged <- "Note: Orkney, Shetland, & Western health boards were merged into 'Island HBs'; Borders & Dumfries and Galloway health boards were merged into 'B,D&G HB'"
vertical_scale_differs_between_panels_text <- "Note: vertical axis not on the same scale between panels!"

figure_deaths_at_home_by_health_board <-
  merged_deaths_hb %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_by_health_board"), extensions = c(".pdf",".svg",".png"), plot = figure_deaths_at_home_by_health_board, width = 12, height = 9, dpi = 300, units = "in")

figure_deaths_at_home_by_health_board
```



## Deaths at home with 2-week moving average, by health board

```{r, fig.width=12, fig.height=9, warning=FALSE}
moving_average_text <- "All figures represent deaths averaged over past 2 weeks; this includes historical range and historical mean."

figure_deaths_at_home_2week_average_by_health_board <-
  merged_deaths_hb %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(ma2w_deaths_all_causes, ma2w_deaths_non_covid), 
               names_to = "deaths_type", values_to = "ma2w_deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = ma2w_deaths_min, ymax = ma2w_deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = ma2w_deaths, colour = deaths_type)) +
  geom_line(aes(y = ma2w_deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(moving_average_text, vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_2week_average_by_health_board"), extensions = c(".pdf",".svg",".png"), plot = figure_deaths_at_home_2week_average_by_health_board, width = 12, height = 9, dpi = 300, units = "in")

figure_deaths_at_home_2week_average_by_health_board
```



## Deaths at home, by local authority

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_by_local_authority <-
  merged_deaths_la %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_by_local_authority"), extensions = c(".pdf",".svg",".png"), plot = figure_deaths_at_home_by_local_authority, width = 12, height = 9, dpi = 300, units = "in")

figure_deaths_at_home_by_local_authority
```


## Deaths at home with 2-week moving average, by local authority

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_2week_average_by_local_authority <-
  merged_deaths_la %>%
  filter(place_of_death == "Home & other non-institution") %>%
  pivot_longer(cols = c(ma2w_deaths_all_causes, ma2w_deaths_non_covid), 
               names_to = "deaths_type", values_to = "ma2w_deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = ma2w_deaths_min, ymax = ma2w_deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = ma2w_deaths, colour = deaths_type)) +
  geom_line(aes(y = ma2w_deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_wrap(~ref_area, scales = "free_y") +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(moving_average_text, vertical_line_text, vertical_scale_differs_between_panels_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_2week_average_by_local_authority"), extensions = c(".pdf",".svg",".png"), plot = figure_deaths_at_home_2week_average_by_local_authority, width = 12, height = 9, dpi = 300, units = "in")

figure_deaths_at_home_2week_average_by_local_authority
```


## Deaths at home by age

```{r, fig.width=12, fig.height=9, warning=FALSE}
removed_under_15_text <- glue::glue("Excluding individuals aged <15 at death, total N={merged_deaths_age %>% filter(age %in% c('0','1-14') & place_of_death == 'Home & other non-institution') %>% .$deaths_all_causes %>% sum} for weeks 1-{max(merged_deaths_age %>% filter(year==2020) %>% .$week_number)} in 2020 and 1-{max(merged_deaths_age %>% filter(year==2021) %>% .$week_number)} in 2021.")

figure_deaths_at_home_by_age <-
  merged_deaths_age %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  filter(!age %in% c('0','1-14')) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  # facet_wrap(~age, scales = "free_y") +
  facet_wrap(~age) +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text,removed_under_15_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_by_age"), extensions = c(".pdf",".svg",".png"), plot = figure_deaths_at_home_by_age, width = 12, height = 9, dpi = 300, units = "in")

figure_deaths_at_home_by_age
```


## Deaths at home by sex

```{r, fig.width=12, fig.height=9, warning=FALSE}
figure_deaths_at_home_by_sex <-
  merged_deaths_sex %>%
  mutate(sex = if_else(sex=="F", "Female", "Male")) %>%
  filter(place_of_death %in% c("Home & other non-institution")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", size = 0.2) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  facet_grid(~sex) +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(vertical_line_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

save_output_file(filename = paste0(dir_outputs,"/figure_deaths_at_home_by_sex"), extensions = c(".pdf",".svg",".png"), plot = figure_deaths_at_home_by_sex, width = 12, height = 9, dpi = 300, units = "in")

figure_deaths_at_home_by_sex
```


## Overall deaths at home 2020 by cause of death

```{r}
# TODO: add yearly range for all deaths
# TODO: split data by covid-underlying cause of desath & covid-factor in death
merged_deaths_overall %>%
  filter(sex=="all", age=="all") %>%
  filter(year==2020) %>%
  filter(place_of_death == "Home & other non-institution") %>%
  group_by(ref_area, year) %>%
  summarise(
    deaths_all_causes = sum(deaths_all_causes, na.rm=TRUE),
    deaths_covid_related = sum(deaths_covid_related, na.rm=TRUE),
    deaths_non_covid = sum(deaths_non_covid, na.rm=TRUE)
  )
```


# Case counts & home deaths - comparing plots

## Scotland-wide figure

```{r}
# TODO: wokr out how to include both... two panels? two axes on same plot?

ratio_max_weekly_deaths_to_cases <- 600 / 16e3


figure_weekly_deaths_to_cases_part_1 <-
  merged_deaths_overall %>%
  filter(sex=="all" & age=="all" & str_starts(place_of_death, "Home")) %>%
  left_join(weekly_covid_cases_overall, by=c("year","week_number","date_w_c","week_number_run_over","ref_area")) %>%
  pivot_longer(cols = c(deaths_all_causes, deaths_non_covid), 
               names_to = "deaths_type", values_to = "deaths") %>% 
  ggplot(aes(x = week_number_run_over)) +
  geom_ribbon(aes(ymin = deaths_min, ymax = deaths_max), fill = "#4477aa", alpha = 0.5) +
  geom_line(aes(y = deaths, colour = deaths_type)) +
  geom_line(aes(y = deaths_mean), linetype = "dashed", colour="grey20") +
  # geom_line(aes(y = weekly_positive * ratio_max_weekly_deaths_to_cases), colour="purple") +
  geom_vline(xintercept = 54, linetype = "dotted") +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  # scale_y_continuous(sec.axis = sec_axis(trans = ~./ratio_max_weekly_deaths_to_cases, name = "Weekly cases")) +
  # ylim(0, 600) +  # start scale at 0 for better understanding the scale of deaths
  facet_grid(~place_of_death) +
  # theme_minimal() +
  scale_colour_manual(values = c("red","blue"),  # custom legend for the two lines
                      labels = c("All deaths", 
                                 "Non Covid-19 deaths"),
                      guide = guide_legend(label.hjust = 0.5, override.aes = list(size = 5))
                      ) +
  # annotate(geom = "text", label = total_deaths_at_home_in_period, x = 25, y = 575, hjust=0) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  labs(x = "Week number",
       y = "Deaths (N)",
       subtitle = date_range_text,
       caption = paste0(c(dashed_line_historical_range_text,vertical_line_text, death_registrations_text, source_nrs_text), collapse="\n"),
       colour = "Cause of death"
       )

figure_weekly_deaths_to_cases_part_2 <-
  merged_deaths_overall %>%
  filter(sex=="all" & age=="all" & str_starts(place_of_death, "Home")) %>%
  left_join(weekly_covid_cases_overall, by=c("year","week_number","date_w_c","week_number_run_over","ref_area")) %>%
  ggplot(aes(x=week_number_run_over, y=weekly_positive)) +
  geom_line(size=1) +
  geom_vline(xintercept = 54, linetype = "dotted") +
  # theme_minimal() +
  facet_grid(~ref_area) +
  theme(legend.position = "top", plot.caption = element_text(size = 10, colour = "gray60")) +
  scale_x_continuous(breaks = seq(0,60,by=10)) +
  scale_y_continuous(labels = function(x) format(x, big.mark=",")) +
  labs(
    x = "Week number", y = "COVID-19 positive cases (N)",
    subtitle = "Note the different scale for positive cases!",
    caption = paste0(c(source_phs_text), collapse="\n")
  )

figure_weekly_deaths_to_cases <- wrap_plots(figure_weekly_deaths_to_cases_part_1,figure_weekly_deaths_to_cases_part_2, ncol = 1)

## figure for a bit less than half A4 page is approx 14*11cm
save_output_file(filename = paste0(dir_outputs,"/figure_weekly_deaths_to_cases"), extensions = c(".pdf",".svg",".png"), plot = figure_weekly_deaths_to_cases,width = 15, height = 15, units = "cm", dpi = 300)

figure_weekly_deaths_to_cases
```


# Map-based visualisations

## Ratio of 2020 home deaths to historical home deaths by LA / HB

```{r}
areas_relatively_higher_number_home_deaths_text <- "Lighter areas represent areas with relatively higher number of home deaths in 2020 compared to historical mean"
home_deaths_ratio_text <- "Ratio computed from total home deaths in 2020 divided by mean annual home deaths 2015-2019"

## max/min used for setting scale of fill colour so it's consistent between plots!
maximum_ratio_between_hb_and_la_home_deaths <-
  bind_rows(
    total_deaths_la,
    total_deaths_hb
  ) %>%
  filter(year==2020 & place_of_death == "Home & other non-institution") %>%
  .$ratio_annual_deaths_to_historical_mean %>%
  max

minimum_ratio_between_hb_and_la_home_deaths <-
  bind_rows(
    total_deaths_la,
    total_deaths_hb
  ) %>%
  filter(year==2020 & place_of_death == "Home & other non-institution") %>%
  .$ratio_annual_deaths_to_historical_mean %>%
  min %>%
  round(digits=1)
```

### LA

```{r, fig.height=12, fig.width=8}
# TODO: work out the size of these plots
figure_map_ratio_home_deaths_2020_to_historical_la <-
  total_deaths_la %>%
  filter(
    year == 2020 & place_of_death == "Home & other non-institution"
  ) %>%
  mutate(percent_increase_home_death = ratio_annual_deaths_to_historical_mean - 1) %>%
  left_join(shapefile_la, by=c("ref_area"="LAD20NM")) %>%
  ggplot(aes(geometry=geometry, fill=percent_increase_home_death), colour="grey10") +
  geom_sf(colour="grey10") +
  # scale_fill_viridis_b(limits = c(minimum_ratio_between_hb_and_la_home_deaths-1, maximum_ratio_between_hb_and_la_home_deaths-1), labels = function(x) scales::percent(x, accuracy = 1)) +
  scale_fill_viridis_b(labels = function(x) scales::percent(x, accuracy = 1)) +
  theme(axis.text = element_blank(), panel.grid = element_blank()) +
  labs(x="", y="",
       title = str_wrap("Increased home deaths in 2020 relative to historical mean 2015-2019, by Local Authority", width=50),
       # subtitle = str_wrap("A ratio of 1 means there was no increase; A ratio of 1.6 means there was a 60% increase of home deaths in 2020 over the mean 2015-2019.", width = 80),
       # caption = paste0(c(areas_relatively_higher_number_home_deaths_text, home_deaths_ratio_text, source_nrs_text), collapse="\n"),
       caption = paste0(c(source_nrs_text), collapse="\n"),
       fill = "Home death\nincrease"
       ) +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_map_ratio_home_deaths_2020_to_historical_la"), extensions = c(".pdf",".svg",".png"), plot = figure_map_ratio_home_deaths_2020_to_historical_la, width = 12, height = 14, dpi = 300, units = "cm")

figure_map_ratio_home_deaths_2020_to_historical_la
```

#### Grayscale version of the same

```{r}
figure_map_ratio_home_deaths_2020_to_historical_la_bw <-
  figure_map_ratio_home_deaths_2020_to_historical_la +
  scale_fill_gradient(low = "grey10", high = "grey75", labels = function(x) scales::percent(x, accuracy = 1)) +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_map_ratio_home_deaths_2020_to_historical_la_bw"), extensions = c(".pdf",".svg",".png"), plot = figure_map_ratio_home_deaths_2020_to_historical_la_bw, width = 12, height = 14, dpi = 300, units = "cm")
```

### HB

```{r, fig.height=12, fig.width=8}
figure_map_ratio_home_deaths_2020_to_historical_hb <-
  total_deaths_hb %>%
  filter(
    year == 2020 & place_of_death == "Home & other non-institution"
  ) %>%
  mutate(percent_increase_home_death = ratio_annual_deaths_to_historical_mean - 1) %>%
  left_join(shapefile_hb_uk_wide, by=c("ref_area"="name")) %>%
  # ggplot(aes(geometry=geometry, fill=ratio_annual_deaths_to_historical_mean), colour="grey10") +
  ggplot(aes(geometry=geometry, fill=percent_increase_home_death), colour="grey10") +
  geom_sf(colour="grey10") +
  # scale_fill_viridis_b(limits = c(minimum_ratio_between_hb_and_la_home_deaths-1, maximum_ratio_between_hb_and_la_home_deaths-1), labels = function(x) scales::percent(x, accuracy = 1)) +
  scale_fill_viridis_b(labels = function(x) scales::percent(x, accuracy = 1)) +
  theme(
    axis.text = element_blank(), 
    panel.grid = element_blank(), 
    aspect.ratio = 1.4,  # needed for Scotland HB plot
    plot.margin = margin(5,5,5,5),
    # legend.position = c(1.2,0.4)  # this was manually tweaked until just right  # problem - edge gets cut
    ) +
  labs(x="", y="",
       title = str_wrap("Increased home deaths in 2020 relative to historical mean 2015-2019, by Health Board", width=50),
       # subtitle = str_wrap("A ratio of 1 means there was no increase; A ratio of 1.6 means there was a 60% increase of home deaths in 2020 over the mean 2015-2019.", width = 80),
       # caption = paste0(c(areas_relatively_higher_number_home_deaths_text, home_deaths_ratio_text, source_nrs_text), collapse="\n"),
       caption = paste0(c(source_nrs_text), collapse="\n"),
       # fill = "Ratio"
       fill = "Home death\nincrease"
       ) +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_map_ratio_home_deaths_2020_to_historical_hb"), extensions = c(".pdf",".svg",".png"), plot = figure_map_ratio_home_deaths_2020_to_historical_hb, width = 12, height = 14, dpi = 300, units = "cm")

figure_map_ratio_home_deaths_2020_to_historical_hb
```

#### Grayscale version of the same

```{r}
figure_map_ratio_home_deaths_2020_to_historical_hb_bw <-
  figure_map_ratio_home_deaths_2020_to_historical_hb +
  scale_fill_gradient(low = "grey10", high = "grey75", labels = function(x) scales::percent(x, accuracy = 1)) +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_map_ratio_home_deaths_2020_to_historical_hb_bw"), extensions = c(".pdf",".svg",".png"), plot = figure_map_ratio_home_deaths_2020_to_historical_hb_bw, width = 12, height = 14, dpi = 300, units = "cm")
```


## Per capita cases of COVID-19 by region

```{r}
areas_relatively_higher_number_cases <- "Lighter areas represent areas with relatively higher number of COVID-19 cases per 100,000 population in 2020"
```

### LA

```{r, fig.height=12, fig.width=8}
figure_map_per_capita_covid_cases_2020_la <-
  weekly_covid_cases_la %>%
  filter(year == 2020 & week_number == 53) %>%
  left_join(shapefile_la, by=c("ref_area"="LAD20NM")) %>%
  ggplot(aes(geometry=geometry, fill=crude_rate_positive_per100k), colour="grey10") +
  geom_sf(colour="grey10") +
  scale_fill_viridis_b(option = "B", labels = function(x) format(x, big.mark=",")) +
  theme(axis.text = element_blank(), panel.grid = element_blank()) +
  labs(x="", y="",
       title = str_wrap("Total COVID-19 cases in 2020 per 100,000 population, by Local Authority",width=50),
       subtitle = "",
       caption = paste0(c(source_phs_text), collapse="\n"),
       fill = str_wrap("Cases per 100,000 population", width = 15)
       ) +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_map_per_capita_covid_cases_2020_la"), extensions = c(".pdf",".svg",".png"), plot = figure_map_per_capita_covid_cases_2020_la, width = 12, height = 14, dpi = 300, units = "cm")

figure_map_per_capita_covid_cases_2020_la
```

#### Grayscale version of the same

```{r}
figure_map_per_capita_covid_cases_2020_la_bw <-
  figure_map_per_capita_covid_cases_2020_la +
  scale_fill_gradient(low = "grey10", high = "grey75", labels = function(x) format(x, big.mark=",")) +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_map_per_capita_covid_cases_2020_la_bw"), extensions = c(".pdf",".svg",".png"), plot = figure_map_per_capita_covid_cases_2020_la_bw, width = 12, height = 14, dpi = 300, units = "cm")
```

### HB

```{r, fig.height=12, fig.width=8}
figure_map_per_capita_covid_cases_2020_hb <-
  weekly_covid_cases_hb %>%
  filter(year == 2020 & week_number == 53) %>%
  left_join(shapefile_hb_uk_wide, by=c("ref_area"="name")) %>%
  ggplot(aes(geometry=geometry, fill=crude_rate_positive_per100k), colour="grey10") +
  geom_sf(colour="grey10") +
  scale_fill_viridis_b(option = "B", labels = function(x) format(x, big.mark=",")) +
  theme(axis.text = element_blank(), panel.grid = element_blank(), aspect.ratio = 1.4) +
  labs(x="", y="",
       title = str_wrap("Total cases of COVID-19 in 2020 per 100,000 population, by Health Board",width=50),
       subtitle = "",
       caption = paste0(c(source_phs_text), collapse="\n"),
       fill = str_wrap("Cases per 100,000 population", width = 15)
       ) +
  NULL

  
save_output_file(filename = paste0(dir_outputs,"/figure_map_per_capita_covid_cases_2020_hb"), extensions = c(".pdf",".svg",".png"), plot = figure_map_per_capita_covid_cases_2020_hb, width = 12, height = 14, dpi = 300, units = "cm")

figure_map_per_capita_covid_cases_2020_hb
```


#### Grayscale version of the same

```{r}
figure_map_per_capita_covid_cases_2020_hb_bw <-
  figure_map_per_capita_covid_cases_2020_hb +
  scale_fill_gradient(low = "grey10", high = "grey75", labels = function(x) format(x, big.mark=",")) +
  NULL

save_output_file(filename = paste0(dir_outputs,"/figure_map_per_capita_covid_cases_2020_hb_bw"), extensions = c(".pdf",".svg",".png"), plot = figure_map_per_capita_covid_cases_2020_hb_bw, width = 12, height = 14, dpi = 300, units = "cm")
```


## Merged maps of home death ratios & covid cases

### HB

```{r}
# TODO: work out where all the extra space comes from around plot & legends

figure_map_home_deaths_ratios_2020_and_per_capita_cases <-
  wrap_plots(
    figure_map_ratio_home_deaths_2020_to_historical_hb + 
      labs(
        caption = source_nrs_text,   # keep source captions only
        fill = str_wrap("Home deaths increase over historic mean",width = 20),
        subtitle = NULL,
        title = str_wrap("Increased home deaths 2020", width = 20),
        x = NULL,
        y = NULL
        ) +
      theme(plot.margin = margin(0,0,0,0), legend.box.margin = margin(0,0,0,0))
    ,
      # theme(legend.position = "left"),
    figure_map_per_capita_covid_cases_2020_hb + 
      labs(
        caption = source_phs_text,
        title = str_wrap("COVID cases 2020", width = 20),
        x = NULL,
        y = NULL
        ) + 
      theme(plot.margin = margin(0,0,0,0), legend.box.margin = margin(0,0,0,0))
    ,
    nrow = 1  # force to same row  
  )
  
save_output_file(filename = paste0(dir_outputs,"/figure_map_home_deaths_ratios_2020_and_per_capita_cases"), extensions = c(".pdf",".svg",".png"), plot = figure_map_home_deaths_ratios_2020_and_per_capita_cases, width = 20, height = 10, dpi = 300, units = "cm")
```


# Save most recent workspace for further analyses

```{r}
save.image(file = "./workspace.RData", safe = TRUE)
```

# Print session info

```{r}
sessionInfo()
```

